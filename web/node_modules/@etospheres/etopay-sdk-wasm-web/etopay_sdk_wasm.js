let wasm;

const cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );

if (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };

let cachedUint8ArrayMemory0 = null;

function getUint8ArrayMemory0() {
    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8ArrayMemory0;
}

function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}

function addToExternrefTable0(obj) {
    const idx = wasm.__externref_table_alloc();
    wasm.__wbindgen_export_2.set(idx, obj);
    return idx;
}

function handleError(f, args) {
    try {
        return f.apply(this, args);
    } catch (e) {
        const idx = addToExternrefTable0(e);
        wasm.__wbindgen_exn_store(idx);
    }
}

let WASM_VECTOR_LEN = 0;

const cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );

const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
    ? function (arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
}
    : function (arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
});

function passStringToWasm0(arg, malloc, realloc) {

    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length, 1) >>> 0;
        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len, 1) >>> 0;

    const mem = getUint8ArrayMemory0();

    let offset = 0;

    for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }

    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);

        offset += ret.written;
        ptr = realloc(ptr, len, offset, 1) >>> 0;
    }

    WASM_VECTOR_LEN = offset;
    return ptr;
}

function isLikeNone(x) {
    return x === undefined || x === null;
}

let cachedDataViewMemory0 = null;

function getDataViewMemory0() {
    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {
        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
    }
    return cachedDataViewMemory0;
}

function getArrayU8FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
}

const CLOSURE_DTORS = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(state => {
    wasm.__wbindgen_export_6.get(state.dtor)(state.a, state.b)
});

function makeMutClosure(arg0, arg1, dtor, f) {
    const state = { a: arg0, b: arg1, cnt: 1, dtor };
    const real = (...args) => {
        // First up with a closure we increment the internal reference
        // count. This ensures that the Rust closure environment won't
        // be deallocated while we're invoking it.
        state.cnt++;
        const a = state.a;
        state.a = 0;
        try {
            return f(a, state.b, ...args);
        } finally {
            if (--state.cnt === 0) {
                wasm.__wbindgen_export_6.get(state.dtor)(a, state.b);
                CLOSURE_DTORS.unregister(state);
            } else {
                state.a = a;
            }
        }
    };
    real.original = state;
    CLOSURE_DTORS.register(real, state, state);
    return real;
}

function debugString(val) {
    // primitive types
    const type = typeof val;
    if (type == 'number' || type == 'boolean' || val == null) {
        return  `${val}`;
    }
    if (type == 'string') {
        return `"${val}"`;
    }
    if (type == 'symbol') {
        const description = val.description;
        if (description == null) {
            return 'Symbol';
        } else {
            return `Symbol(${description})`;
        }
    }
    if (type == 'function') {
        const name = val.name;
        if (typeof name == 'string' && name.length > 0) {
            return `Function(${name})`;
        } else {
            return 'Function';
        }
    }
    // objects
    if (Array.isArray(val)) {
        const length = val.length;
        let debug = '[';
        if (length > 0) {
            debug += debugString(val[0]);
        }
        for(let i = 1; i < length; i++) {
            debug += ', ' + debugString(val[i]);
        }
        debug += ']';
        return debug;
    }
    // Test for built-in
    const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
    let className;
    if (builtInMatches && builtInMatches.length > 1) {
        className = builtInMatches[1];
    } else {
        // Failed to match the standard '[object ClassName]'
        return toString.call(val);
    }
    if (className == 'Object') {
        // we're a user defined class or Object
        // JSON.stringify avoids problems with cycles, and is generally much
        // easier than looping through ownProperties of `val`.
        try {
            return 'Object(' + JSON.stringify(val) + ')';
        } catch (_) {
            return 'Object';
        }
    }
    // errors
    if (val instanceof Error) {
        return `${val.name}: ${val.message}\n${val.stack}`;
    }
    // TODO we could test for more things here, like `Set`s and `Map`s.
    return className;
}

function getArrayJsValueFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    const mem = getDataViewMemory0();
    const result = [];
    for (let i = ptr; i < ptr + 4 * len; i += 4) {
        result.push(wasm.__wbindgen_export_2.get(mem.getUint32(i, true)));
    }
    wasm.__externref_drop_slice(ptr, len);
    return result;
}

function passArrayJsValueToWasm0(array, malloc) {
    const ptr = malloc(array.length * 4, 4) >>> 0;
    for (let i = 0; i < array.length; i++) {
        const add = addToExternrefTable0(array[i]);
        getDataViewMemory0().setUint32(ptr + 4 * i, add, true);
    }
    WASM_VECTOR_LEN = array.length;
    return ptr;
}

function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
}

function passArray8ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 1, 1) >>> 0;
    getUint8ArrayMemory0().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}
function __wbg_adapter_36(arg0, arg1) {
    wasm._dyn_core__ops__function__FnMut_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hf1b1f6e4c1f58c95(arg0, arg1);
}

function __wbg_adapter_39(arg0, arg1) {
    wasm._dyn_core__ops__function__FnMut_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__heb45861aed7ddaa2(arg0, arg1);
}

function __wbg_adapter_42(arg0, arg1, arg2) {
    wasm.closure3503_externref_shim(arg0, arg1, arg2);
}

function __wbg_adapter_530(arg0, arg1, arg2, arg3) {
    wasm.closure3537_externref_shim(arg0, arg1, arg2, arg3);
}

/**
 * @enum {0 | 1}
 */
export const Currency = Object.freeze({
    Iota: 0, "0": "Iota",
    Eth: 1, "1": "Eth",
});
/**
 * @enum {0 | 1 | 2 | 3 | 4}
 */
export const Level = Object.freeze({
    Error: 0, "0": "Error",
    Warn: 1, "1": "Warn",
    Info: 2, "2": "Info",
    Debug: 3, "3": "Debug",
    Trace: 4, "4": "Trace",
});
/**
 * @enum {0 | 1 | 2}
 */
export const OfficialDocumentType = Object.freeze({
    Passport: 0, "0": "Passport",
    DriversLicense: 1, "1": "DriversLicense",
    Id: 2, "2": "Id",
});
/**
 * @enum {0 | 1 | 2}
 */
export const Protocol = Object.freeze({
    /**
     * Represents an EVM-based network (e.g., Ethereum)
     */
    Evm: 0, "0": "Evm",
    /**
     * Represents and EVM based ERC20 Smart Contract token
     */
    EvmERC20: 1, "1": "EvmERC20",
    /**
     * Iota Rebased network.
     */
    IotaRebased: 2, "2": "IotaRebased",
});
/**
 * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7}
 */
export const TxStatus = Object.freeze({
    Pending: 0, "0": "Pending",
    WaitingForVerification: 1, "1": "WaitingForVerification",
    Valid: 2, "2": "Valid",
    Invalid: 3, "3": "Invalid",
    ProcessingIncoming: 4, "4": "ProcessingIncoming",
    ProcessingOutgoing: 5, "5": "ProcessingOutgoing",
    Completed: 6, "6": "Completed",
    Failed: 7, "7": "Failed",
});
/**
 * @enum {0 | 1 | 2}
 */
export const ViviswapVerificationStatus = Object.freeze({
    /**
     * The user is fully verified
     */
    Verified: 0, "0": "Verified",
    /**
     * The user is not verified
     */
    Unverified: 1, "1": "Unverified",
    /**
     * The user is partially verified
     */
    PartiallyVerified: 2, "2": "PartiallyVerified",
});
/**
 * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6}
 */
export const ViviswapVerificationStep = Object.freeze({
    /**
     * no verification step (no next verification step available)
     */
    Undefined: 0, "0": "Undefined",
    /**
     * general verification step
     */
    General: 1, "1": "General",
    /**
     * personal verification step
     */
    Personal: 2, "2": "Personal",
    /**
     * residence verification step
     */
    Residence: 3, "3": "Residence",
    /**
     * identity verification step
     */
    Identity: 4, "4": "Identity",
    /**
     * amla general verification step
     */
    Amla: 5, "5": "Amla",
    /**
     * document verification step
     */
    Documents: 6, "6": "Documents",
});
/**
 * @enum {0 | 1 | 2}
 */
export const WalletTxStatus = Object.freeze({
    Pending: 0, "0": "Pending",
    Confirmed: 1, "1": "Confirmed",
    Conflicting: 2, "2": "Conflicting",
});

const __wbindgen_enum_RequestCredentials = ["omit", "same-origin", "include"];

const __wbindgen_enum_RequestMode = ["same-origin", "no-cors", "cors", "navigate"];

const ApplicationMetadataFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_applicationmetadata_free(ptr >>> 0, 1));

export class ApplicationMetadata {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ApplicationMetadata.prototype);
        obj.__wbg_ptr = ptr;
        ApplicationMetadataFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    toJSON() {
        return {
            product_hash: this.product_hash,
            reason: this.reason,
            purchase_model: this.purchase_model,
            app_data: this.app_data,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ApplicationMetadataFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_applicationmetadata_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    get product_hash() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_applicationmetadata_product_hash(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set product_hash(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_product_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get reason() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_applicationmetadata_reason(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set reason(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_reason(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get purchase_model() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_applicationmetadata_purchase_model(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set purchase_model(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_purchase_model(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get app_data() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_applicationmetadata_app_data(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set app_data(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_app_data(this.__wbg_ptr, ptr0, len0);
    }
}

const CaseDetailsResponseFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_casedetailsresponse_free(ptr >>> 0, 1));

export class CaseDetailsResponse {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CaseDetailsResponse.prototype);
        obj.__wbg_ptr = ptr;
        CaseDetailsResponseFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CaseDetailsResponseFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_casedetailsresponse_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    get case_id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_casedetailsresponse_case_id(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set case_id(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_product_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {boolean}
     */
    get archived() {
        const ret = wasm.__wbg_get_casedetailsresponse_archived(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {boolean} arg0
     */
    set archived(arg0) {
        wasm.__wbg_set_casedetailsresponse_archived(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {string}
     */
    get status() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_casedetailsresponse_status(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set status(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_reason(this.__wbg_ptr, ptr0, len0);
    }
}

const ETOPaySdkFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_etopaysdk_free(ptr >>> 0, 1));
/**
 * Main object that contains all the functionality for interfacing with the ETOPaySdk.
 */
export class ETOPaySdk {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ETOPaySdkFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_etopaysdk_free(ptr, 0);
    }
    /**
     * Create a new instance of the `ETOPaySdk`
     * @returns {ETOPaySdk} a new `ETOPaySdk` instance.
     */
    constructor() {
        const ret = wasm.etopaysdk_new();
        this.__wbg_ptr = ret >>> 0;
        ETOPaySdkFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * Set the configuration as a JSON-encoded string.
     *
     * @param {String} config The input string representing the configuration.
     *
     * @example
     * ```json
     * {
     *     "auth_provider": "<authentication provider name>",
     *     "backend_url": "<valid URL to the backend API>",
     *     "storage_path": "/path/to/valid/folder",
     *     "log_level": "info",
     * }
     * ```
     *
     * @returns {Promise<void>}
     */
    setConfig(config) {
        const ptr0 = passStringToWasm0(config, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_setConfig(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * Selects the network for the ETOPay SDK.
     *
     * @param {String} network_key.
     * @returns {Promise<void>}
     */
    setNetwork(network_key) {
        const ptr0 = passStringToWasm0(network_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_setNetwork(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * Fetch available networks.
     *
     * @returns {Option<Vec<Network>>} Sdk networks
     */
    getNetworks() {
        const ret = wasm.etopaysdk_getNetworks(this.__wbg_ptr);
        return ret;
    }
    /**
     * Initializes the etopay logger
     * @param {Level} level - The log level.
     * @returns {void}
     */
    initLogger(level) {
        wasm.etopaysdk_initLogger(this.__wbg_ptr, level);
    }
    /**
     * Creates a new user for the SDK.
     *
     * @param {string} username - The input string representing the username.
     * @returns {Promise<void>}
     */
    createNewUser(username) {
        const ptr0 = passStringToWasm0(username, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_createNewUser(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * Initializes an existing user in the SDK
     *
     * @param {string} username - The input string representing the username.
     * @returns {Promise<void>}
     */
    initializeUser(username) {
        const ptr0 = passStringToWasm0(username, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_initializeUser(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * Refreshes the access token for the user in the SDK.
     *
     * @param {string} access_token - The input string representing the access token.
     * @returns {Promise<void>}
     */
    refreshAccessToken(access_token) {
        const ptr0 = passStringToWasm0(access_token, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_refreshAccessToken(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * Fetches the kyc verification status for the user
     *
     * @param {string} username - The input string representing the username.
     *
     * @returns {Promise<bool>} The kyc verification status as a boolean value
     */
    isKycVerified(username) {
        const ptr0 = passStringToWasm0(username, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_isKycVerified(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * Creates a new random wallet and returns the mnemonic.
     *
     * @param {string} pin - The input string representing the pin.
     * @returns {Promise<String>}
     */
    createNewWallet(pin) {
        const ptr0 = passStringToWasm0(pin, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_createNewWallet(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * Initializes a wallet from an existing mnemonic.
     *
     * @param {string} pin - The input string representing the pin.
     * @param {string} mnemonic - The input string representing the mnemonic
     * @returns {Promise<void>}
     */
    createWalletFromMnemonic(pin, mnemonic) {
        const ptr0 = passStringToWasm0(pin, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(mnemonic, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_createWalletFromMnemonic(this.__wbg_ptr, ptr0, len0, ptr1, len1);
        return ret;
    }
    /**
     * Creates a wallet from a backup.
     *
     * @param {string} pin - The input string representing the pin.
     * @param {Uint8Array} backup - The bytes of the backup file.
     * @param {string} backup_password - Password used to create the backup.
     *
     * @returns {Promise<void>}
     */
    createWalletFromBackup(pin, backup, backup_password) {
        const ptr0 = passStringToWasm0(pin, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArray8ToWasm0(backup, wasm.__wbindgen_malloc);
        const len1 = WASM_VECTOR_LEN;
        const ptr2 = passStringToWasm0(backup_password, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len2 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_createWalletFromBackup(this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2);
        return ret;
    }
    /**
     * Creates a wallet backup.
     *
     * @param {string} pin - The input string representing the pin.
     * @param {string} backup_password - Password used to create the backup.
     *
     * @returns {Promise<Uint8Array>}
     */
    createWalletBackup(pin, backup_password) {
        const ptr0 = passStringToWasm0(pin, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(backup_password, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_createWalletBackup(this.__wbg_ptr, ptr0, len0, ptr1, len1);
        return ret;
    }
    /**
     * Deletes and existing wallet.
     *
     * @param {string} pin - The input string representing the pin.
     *
     * @returns {Promise<void>}
     */
    deleteWallet(pin) {
        const ptr0 = passStringToWasm0(pin, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_deleteWallet(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * Verify if the provided mnemonic is the one stored in the wallet.
     *
     * @param {string} pin - The input string representing the pin.
     * @param {string} mnemonic - The input string representing the mnemonic.
     *
     * @returns {Promise<boolean>} - whether the mnemonics are the same or not.
     */
    verifyMnemonic(pin, mnemonic) {
        const ptr0 = passStringToWasm0(pin, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(mnemonic, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_verifyMnemonic(this.__wbg_ptr, ptr0, len0, ptr1, len1);
        return ret;
    }
    /**
     * Generate a new receiver address based on selected network in the config.
     *
     * @param {string} pin - The input string representing the pin.
     *
     * @returns {Promise<string>} The receiver wallet address as string
     */
    generateNewAddress(pin) {
        const ptr0 = passStringToWasm0(pin, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_generateNewAddress(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * Fetches the current balance of the base crypto network on the wallet
     *
     * @param {string} pin - The input string representing the pin.
     *
     * @returns {Promise<number>} The current balance as a double precision floating point number
     */
    getWalletBalance(pin) {
        const ptr0 = passStringToWasm0(pin, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_getWalletBalance(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * Initialize the KYC process for Postident
     *
     * @remarks
     * This method is only available if the SDK is compiled with support for postident.
     *
     * @returns {Promise<string>} The ID of the new Postident KYC case.
     */
    startKycVerificationForPostident() {
        const ret = wasm.etopaysdk_startKycVerificationForPostident(this.__wbg_ptr);
        return ret;
    }
    /**
     * Fetches the KYC details for the postident provider
     *
     * @remarks
     * This method is only available if the SDK is compiled with support for postident.
     *
     * @returns {Promise<CaseDetailsResponse>} The case details
     */
    getKycDetailsForPostident() {
        const ret = wasm.etopaysdk_getKycDetailsForPostident(this.__wbg_ptr);
        return ret;
    }
    /**
     * Triggers the backend to update the KYC status in the postident KYC provider
     *
     * @remarks
     * This method is only available if the SDK is compiled with support for postident.
     *
     * @param {string} case_id - The input string representing the case_id to be updated
     * @returns {Promise<void>}
     */
    updateKycStatusForPostident(case_id) {
        const ptr0 = passStringToWasm0(case_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_updateKycStatusForPostident(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * Creates a purchase request for buying an artefact
     *
     * @param receiver - The receiver of the purchase request.
     * @param amount - The amount of the purchase.
     * @param product_hash - The hash of the underlying product/artefact
     * @param app_data - The app data for the purchase. This is application specific string or stringified object data.
     * @param purchase_type - The type of the purchase. Either a COMPLIMENT or a PURCHASE
     *
     * @returns {Promise<string>} The purchase id of the created purchase request as string
     */
    createPurchaseRequest(receiver, amount, product_hash, app_data, purchase_type) {
        const ptr0 = passStringToWasm0(receiver, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(product_hash, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ptr2 = passStringToWasm0(app_data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len2 = WASM_VECTOR_LEN;
        const ptr3 = passStringToWasm0(purchase_type, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len3 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_createPurchaseRequest(this.__wbg_ptr, ptr0, len0, amount, ptr1, len1, ptr2, len2, ptr3, len3);
        return ret;
    }
    /**
     * Fetches the purchase details from the given purchase ID.
     *
     * @param {string} purchase_id - The purchase id to query to details.
     *
     * @returns {Promise<PurchseDetails>} The purchase details
     */
    getPurchaseDetails(purchase_id) {
        const ptr0 = passStringToWasm0(purchase_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_getPurchaseDetails(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * Confirm the purchase for the given purchase ID.
     *
     * @param {string} pin - The pin for confirmation of purchase
     * @param {string} purchase_id - The purchase id to confirm.
     * @returns {Promise<void>}
     */
    confirmPurchaseRequest(pin, purchase_id) {
        const ptr0 = passStringToWasm0(pin, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(purchase_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_confirmPurchaseRequest(this.__wbg_ptr, ptr0, len0, ptr1, len1);
        return ret;
    }
    /**
     * Set the password to use for wallet operations. If the password was already set, this changes it.
     *
     * @param {string} pin - The pin used to encrypt the password
     * @param {string} new_password - The password to set for the wallet
     * @returns {Promise<void>}
     */
    setWalletPassword(pin, new_password) {
        const ptr0 = passStringToWasm0(pin, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(new_password, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_setWalletPassword(this.__wbg_ptr, ptr0, len0, ptr1, len1);
        return ret;
    }
    /**
     * Check if the password to use for wallet operations is set.
     * Use {@link setWalletPassword} to set a new or change an existing password.
     *
     * @returns {Promise<bool>}
     */
    isWalletPasswordSet() {
        const ret = wasm.etopaysdk_isWalletPasswordSet(this.__wbg_ptr);
        return ret;
    }
    /**
     * Verifies the pin for the wallet
     *
     * @param {string} pin - The pin to be verified
     * @returns {Promise<void>}
     */
    verifyPin(pin) {
        const ptr0 = passStringToWasm0(pin, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_verifyPin(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * Change the pin used to encrypt the wallet password
     *
     * @param {string} pin - The old pin
     * @param {string} new_pin - The new pin to be set for the wallet
     * @returns {Promise<void>}
     */
    resetPin(pin, new_pin) {
        const ptr0 = passStringToWasm0(pin, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(new_pin, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_resetPin(this.__wbg_ptr, ptr0, len0, ptr1, len1);
        return ret;
    }
    /**
     * Sends the given amount to the given address
     *
     * @param {string} pin - The pin for verification
     * @param {string} address - The address of the receiver
     * @param {number} amount - The amount to send in the selected currency
     * @param {Uint8Array | undefined} data - The data associated with the transaction. Optional.
     * @returns {Promise<string>} the transaction id.
     */
    sendAmount(pin, address, amount, data) {
        const ptr0 = passStringToWasm0(pin, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        var ptr2 = isLikeNone(data) ? 0 : passArray8ToWasm0(data, wasm.__wbindgen_malloc);
        var len2 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_sendAmount(this.__wbg_ptr, ptr0, len0, ptr1, len1, amount, ptr2, len2);
        return ret;
    }
    /**
     * Estimates the amount of gas required to execute the transaction.
     *
     * @param {string} pin - The pin for verification
     * @param {string} address - The address of the receiver
     * @param {number} amount - The amount to send in the selected currency
     * @param {Uint8Array | undefined} data - The data associated with the transaction. Optional.
     * @return {Promise<string>} The estimated gas as a serialized JSON string
     */
    estimateGas(pin, address, amount, data) {
        const ptr0 = passStringToWasm0(pin, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        var ptr2 = isLikeNone(data) ? 0 : passArray8ToWasm0(data, wasm.__wbindgen_malloc);
        var len2 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_estimateGas(this.__wbg_ptr, ptr0, len0, ptr1, len1, amount, ptr2, len2);
        return ret;
    }
    /**
     * Gets the detailed lists of purchases (COMPLIMENTS and PURCHASES)
     *
     * @param {number} start - The start page
     * @param {number} limit - The limit per page
     *
     * @returns {Promise<TxList>} The details of the created purchases
     */
    getTransactionList(start, limit) {
        const ret = wasm.etopaysdk_getTransactionList(this.__wbg_ptr, start, limit);
        return ret;
    }
    /**
     * Set the account and index used for deriving the private key from the mnemonic. This is used
     * to have multiple accounts and addresses with a single mnemonic.
     *
     * @param {number} account - The account number
     * @param {number} index - The index number
     *
     * @returns {Promise<void>}
     */
    setWalletAccount(account, index) {
        const ret = wasm.etopaysdk_setWalletAccount(this.__wbg_ptr, account, index);
        return ret;
    }
    /**
     * Gets the current exchange rate for the cryptocurrency to EURO
     *
     * @returns {Promise<number>} The exchange rate as a floating point number
     */
    getExchangeRate() {
        const ret = wasm.etopaysdk_getExchangeRate(this.__wbg_ptr);
        return ret;
    }
    /**
     * Deletes the user in etopay. Hazmat!
     *
     * @param {string} pin - The wallet pin for confirmation. Optional in case there is an active wallet.
     * @returns {Promise<void>}
     */
    deleteUser(pin) {
        var ptr0 = isLikeNone(pin) ? 0 : passStringToWasm0(pin, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_deleteUser(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * Gets the detailed lists of wallet transactions
     *
     * @param {pin} pin - The wallet pin
     * @param {string} start - The start page
     * @param {string} limit - The limit per page
     *
     * @returns {Promise<WalletTxInfoList>} The list of wallet transactions
     */
    getWalletTransactionList(pin, start, limit) {
        const ptr0 = passStringToWasm0(pin, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_getWalletTransactionList(this.__wbg_ptr, ptr0, len0, start, limit);
        return ret;
    }
    /**
     * Gets the details of a specific wallet transaction
     *
     * @param {pin} pin - The wallet pin
     * @param {string} tx_id - The ID of the transaction to get details for.
     *
     * @returns {Promise<WalletTxInfo} The details of the wallet transaction as a serialized JSON string.
     */
    getWalletTransaction(pin, tx_id) {
        const ptr0 = passStringToWasm0(pin, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(tx_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_getWalletTransaction(this.__wbg_ptr, ptr0, len0, ptr1, len1);
        return ret;
    }
    /**
     * Updates the IBAN of the user
     *
     * @param {string} pin - The pin for verification
     * @param {string} address - The IBAN number to be updated
     *
     * @returns {Promise<ViviswapAddressDetail>} The details of the added IBAN
     */
    updateIbanViviswap(pin, address) {
        const ptr0 = passStringToWasm0(pin, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_updateIbanViviswap(this.__wbg_ptr, ptr0, len0, ptr1, len1);
        return ret;
    }
    /**
     * Gets the IBAN of the user
     *
     * @returns {Promise<ViviswapAddressDetail} The details of the IBAN
     */
    getIbanViviswap() {
        const ret = wasm.etopaysdk_getIbanViviswap(this.__wbg_ptr);
        return ret;
    }
    /**
     * Creates a payment contract for depositing money in wallet using viviswap [EURO --> Crypto]
     *
     * @param {pin} pin - The wallet pin
     * @returns {Promise<ViviswapDeposit>} The details of the added payment contract
     */
    createDepositWithViviswap(pin) {
        const ptr0 = passStringToWasm0(pin, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_createDepositWithViviswap(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * Creates a payment detail for the wallet crypto address in viviswap
     *
     * @param {pin} pin - The wallet pin
     * @returns {Promise<ViviswapAddressDetail>} The details of the added payment detail
     */
    createDetailForViviswap(pin) {
        const ptr0 = passStringToWasm0(pin, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_createDetailForViviswap(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * Creates a payment contract for withdrawing money from wallet using viviswap [Crypto --> EUR] and if the pin is provided automatically triggers a withdrawal
     *
     * @param {number} amount - The amount to withdraw from the wallet
     * @param {string | undefined} pin - The pin for verification. Optional.
     * @param {Uint8Array | undefined} data - The associated data with the transaction. Optional.
     *
     * @returns {Promise<ViviswapWithdrawal>} The details of the created payment contract
     */
    createWithdrawalWithViviswap(amount, pin, data) {
        var ptr0 = isLikeNone(pin) ? 0 : passStringToWasm0(pin, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        var ptr1 = isLikeNone(data) ? 0 : passArray8ToWasm0(data, wasm.__wbindgen_malloc);
        var len1 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_createWithdrawalWithViviswap(this.__wbg_ptr, amount, ptr0, len0, ptr1, len1);
        return ret;
    }
    /**
     * Gets the detail of a particular swap(deposit or withdrawal) created at viviswap based on the given order id.
     *
     * @param {string} order_id - The amount to withdraw from the wallet
     *
     * @returns {Promise<Order>} The details of the created order
     */
    getSwapDetails(order_id) {
        const ptr0 = passStringToWasm0(order_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_getSwapDetails(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * Gets the detailed lists of swaps (deposit and withdrawal) created at viviswap
     *
     * @param {number} start - The start page
     * @param {number} limit - The limit per page
     *
     * @returns {Promise<OrderList>} The list of created orders
     */
    getSwapList(start, limit) {
        const ret = wasm.etopaysdk_getSwapList(this.__wbg_ptr, start, limit);
        return ret;
    }
    /**
     * Starts the KYC verification process for viviswap
     *
     * @param {string} mail - The email address of the user as a string.
     * @param {boolean} terms_accepted - The terms of conditions accepted flag for the user as a boolean
     *
     * @returns {Promise<NewViviswapUser>} The new viviswap user
     */
    startKycVerificationForViviswap(mail, terms_accepted) {
        const ptr0 = passStringToWasm0(mail, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_startKycVerificationForViviswap(this.__wbg_ptr, ptr0, len0, terms_accepted);
        return ret;
    }
    /**
     * Fetches the KYC details for a user by the viviswap onboarding process
     *
     * @returns {Promise<ViviswapKycStatus>} The KYC details
     */
    getKycDetailsForViviswap() {
        const ret = wasm.etopaysdk_getKycDetailsForViviswap(this.__wbg_ptr);
        return ret;
    }
    /**
     * Updates the partial KYC details for the viviswap onboarding process
     *
     * @param {boolean} is_individual - Flag indicating if the user is an individual.
     * @param {boolean} is_pep - Flag indicating if the user is a politically exposed person.
     * @param {boolean} is_us_citizen - Flag indicating if the user is a US citizen.
     * @param {boolean} is_regulatory_disclosure - Flag indicating if the user has made a regulatory disclosure.
     * @param {string} country_of_residence - The country of residence of the user.
     * @param {string} nationality - The nationality of the user.
     * @param {string} full_name - The full name of the user.
     * @param {string} date_of_birth - The date of birth of the user.
     *
     * @returns {Promise<ViviswapPartiallyKycDetails>} The KYC updated details
     */
    updateKycPartiallyStatusForViviswap(is_individual, is_pep, is_us_citizen, is_regulatory_disclosure, country_of_residence, nationality, full_name, date_of_birth) {
        const ptr0 = passStringToWasm0(country_of_residence, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(nationality, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ptr2 = passStringToWasm0(full_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len2 = WASM_VECTOR_LEN;
        const ptr3 = passStringToWasm0(date_of_birth, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len3 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_updateKycPartiallyStatusForViviswap(this.__wbg_ptr, is_individual, is_pep, is_us_citizen, is_regulatory_disclosure, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3);
        return ret;
    }
    /**
     * Submits the partial KYC details for the viviswap onboarding process
     * @returns {Promise<void>}
     */
    submitKycPartiallyStatusForViviswap() {
        const ret = wasm.etopaysdk_submitKycPartiallyStatusForViviswap(this.__wbg_ptr);
        return ret;
    }
    /**
     * Set Viviswap KYC identity details
     *
     * @param {OfficialDocumentType} official_document_type - The type of the official document.
     * @param {string} expiration_date - The expiration date of the official document.
     * @param {string} document_number - The number of the official document.
     * @param {Uint8Array} official_document_front_image_data -  The data of the image of the front of the official document.
     * @param {string} official_document_front_image_filename - The filename (including extension) of the image of the front of the official document.
     * @param {Uint8Array | undefined} official_document_back_image_data - The data of the image of the back of the official document. Leave as empty string to no provide a back image.
     * @param {string | undefined} official_document_back_image_filename - The filename (including extension) of the image of the back of the official document. Leave as empty string to no provide a back image.
     * @param {Uint8Array | undefined} personal_video_data - The data of the 30 second personal video recording.
     * @param {string} personal_video_filename - The filename (including extenstion) of the 30 second personal video recording.
     * @returns {Promise<void>}
     */
    setViviswapKycIdentityDetails(official_document_type, expiration_date, document_number, official_document_front_image_data, official_document_front_image_filename, official_document_back_image_data, official_document_back_image_filename, personal_video_data, personal_video_filename) {
        const ptr0 = passStringToWasm0(expiration_date, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(document_number, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ptr2 = passArray8ToWasm0(official_document_front_image_data, wasm.__wbindgen_malloc);
        const len2 = WASM_VECTOR_LEN;
        const ptr3 = passStringToWasm0(official_document_front_image_filename, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len3 = WASM_VECTOR_LEN;
        var ptr4 = isLikeNone(official_document_back_image_data) ? 0 : passArray8ToWasm0(official_document_back_image_data, wasm.__wbindgen_malloc);
        var len4 = WASM_VECTOR_LEN;
        var ptr5 = isLikeNone(official_document_back_image_filename) ? 0 : passStringToWasm0(official_document_back_image_filename, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len5 = WASM_VECTOR_LEN;
        const ptr6 = passArray8ToWasm0(personal_video_data, wasm.__wbindgen_malloc);
        const len6 = WASM_VECTOR_LEN;
        const ptr7 = passStringToWasm0(personal_video_filename, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len7 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_setViviswapKycIdentityDetails(this.__wbg_ptr, official_document_type, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, ptr4, len4, ptr5, len5, ptr6, len6, ptr7, len7);
        return ret;
    }
    /**
     * Set Viviswap KYC residence details
     *
     * @param {string} country_code - User country code
     * @param {string} region - User region
     * @param {string} zip_code - User zip code
     * @param {string} city - User city
     * @param {string} address_line_1 - User address line 1
     * @param {string} address_line_2 - User address line 2
     * @param {boolean} is_public_entry - Inidcates that a valid public entry of this clients address can be found.
     * @param {string | undefined} public_entry_reference - if `is_public_entry` is `true`, then this must contain the resource link.
     * @param {boolean} has_no_official_document - indicates if the client does not have any document verifying their address.
     * @param {Uint8Array | undefined} official_document_image_data - if `has_no_official_document` is `false`, then this must contain the
     *                                                                 bytes of the document file that verifies that this person is currently living at the address.
     * @param {string | undefined} official_document_image_filename - the filename (including extension) of the document.
     * @returns {Promise<void>}
     */
    setViviswapKycResidenceDetails(country_code, region, zip_code, city, address_line_1, address_line_2, is_public_entry, public_entry_reference, has_no_official_document, official_document_image_data, official_document_image_filename) {
        const ptr0 = passStringToWasm0(country_code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(region, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ptr2 = passStringToWasm0(zip_code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len2 = WASM_VECTOR_LEN;
        const ptr3 = passStringToWasm0(city, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len3 = WASM_VECTOR_LEN;
        const ptr4 = passStringToWasm0(address_line_1, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len4 = WASM_VECTOR_LEN;
        const ptr5 = passStringToWasm0(address_line_2, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len5 = WASM_VECTOR_LEN;
        var ptr6 = isLikeNone(public_entry_reference) ? 0 : passStringToWasm0(public_entry_reference, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len6 = WASM_VECTOR_LEN;
        var ptr7 = isLikeNone(official_document_image_data) ? 0 : passArray8ToWasm0(official_document_image_data, wasm.__wbindgen_malloc);
        var len7 = WASM_VECTOR_LEN;
        var ptr8 = isLikeNone(official_document_image_filename) ? 0 : passStringToWasm0(official_document_image_filename, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len8 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_setViviswapKycResidenceDetails(this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, ptr4, len4, ptr5, len5, is_public_entry, ptr6, len6, has_no_official_document, ptr7, len7, ptr8, len8);
        return ret;
    }
    /**
     * Get the open AMLA KYC questions
     *
     * @returns {Promise<OpenAmlaQuestions>} A list of the currently open AMLA questions.
     */
    getViviswapKycAmlaOpenQuestions() {
        const ret = wasm.etopaysdk_getViviswapKycAmlaOpenQuestions(this.__wbg_ptr);
        return ret;
    }
    /**
     * Set the answer to an open AMLA KYC question
     *
     * @param {string} question_id - The ID of the question to set the answer to.
     * @param {string} answers - a list of the selected available answers for the question.
     * @param {string | undefined} freetext_answer - an optional free-text answer.
     * @returns {Promise<void>}
     */
    setViviswapKycAmlaAnswer(question_id, answers, freetext_answer) {
        const ptr0 = passStringToWasm0(question_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArrayJsValueToWasm0(answers, wasm.__wbindgen_malloc);
        const len1 = WASM_VECTOR_LEN;
        var ptr2 = isLikeNone(freetext_answer) ? 0 : passStringToWasm0(freetext_answer, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len2 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_setViviswapKycAmlaAnswer(this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2);
        return ret;
    }
    /**
     * Get the currently open/missing documents for KYC
     *
     * @returns {Promise<OpenDocuments>} A list of the currently open documents.
     */
    getViviswapKycOpenDocuments() {
        const ret = wasm.etopaysdk_getViviswapKycOpenDocuments(this.__wbg_ptr);
        return ret;
    }
    /**
     * Set / upload an open KYC document
     *
     * @param {string} document_id - The ID of the document to upload.
     * @param {string} expiration_date - the expiration date of this document.
     * @param {string} document_number - the official document number.
     * @param {Uint8Array} front_image_data - the image data of the front side of the document.
     * @param {string} front_image_filename - the filename (including extension) of the front side of the document.
     * @param {Uint8Array | undefined} back_image_data - the image data of the back side of the document. Leave empty for not specifying a back side image.
     * @param {string} back_image_filename - the filename (including extension) of the back side of the document. Leave empty for not specifying a back side image.
     * @returns {Promise<void>}
     */
    setViviswapKycDocument(document_id, expiration_date, document_number, front_image_data, front_image_filename, back_image_data, back_image_filename) {
        const ptr0 = passStringToWasm0(document_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(expiration_date, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ptr2 = passStringToWasm0(document_number, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len2 = WASM_VECTOR_LEN;
        var ptr3 = isLikeNone(front_image_data) ? 0 : passArray8ToWasm0(front_image_data, wasm.__wbindgen_malloc);
        var len3 = WASM_VECTOR_LEN;
        var ptr4 = isLikeNone(front_image_filename) ? 0 : passStringToWasm0(front_image_filename, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len4 = WASM_VECTOR_LEN;
        var ptr5 = isLikeNone(back_image_data) ? 0 : passArray8ToWasm0(back_image_data, wasm.__wbindgen_malloc);
        var len5 = WASM_VECTOR_LEN;
        var ptr6 = isLikeNone(back_image_filename) ? 0 : passStringToWasm0(back_image_filename, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len6 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_setViviswapKycDocument(this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, ptr4, len4, ptr5, len5, ptr6, len6);
        return ret;
    }
    /**
     * Get the recovery share.
     *
     * @returns {Promise<string?>} The recovery share as a string, or `undefined` if none exists.
     */
    getRecoveryShare() {
        const ret = wasm.etopaysdk_getRecoveryShare(this.__wbg_ptr);
        return ret;
    }
    /**
     * Set the recovery share.
     *
     * @param {string} share The recovery share to set.
     * @returns {Promise<void>}
     */
    setRecoveryShare(share) {
        const ptr0 = passStringToWasm0(share, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_setRecoveryShare(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * Get the preferred network.
     *
     * @returns {Promise<String?>} The id of preferred network id, or `undefined` if none exists.
     */
    getPreferredNetwork() {
        const ret = wasm.etopaysdk_getPreferredNetwork(this.__wbg_ptr);
        return ret;
    }
    /**
     * Set the preferred network.
     *
     * @param {String?} network - the id of the network, or null to reset it.
     *
     * @returns {Promise<()>}
     */
    setPreferredNetwork(network) {
        var ptr0 = isLikeNone(network) ? 0 : passStringToWasm0(network, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.etopaysdk_setPreferredNetwork(this.__wbg_ptr, ptr0, len0);
        return ret;
    }
    /**
     * Get sdk build information.
     *
     * @returns {Promise<string?>} The sdk build information as a string.
     */
    getBuildInfo() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.etopaysdk_getBuildInfo(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
}

const GasCostEstimationFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_gascostestimation_free(ptr >>> 0, 1));
/**
 * Gas estimation (EIP-1559)
 */
export class GasCostEstimation {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(GasCostEstimation.prototype);
        obj.__wbg_ptr = ptr;
        GasCostEstimationFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    toJSON() {
        return {
            max_fee_per_gas: this.max_fee_per_gas,
            max_priority_fee_per_gas: this.max_priority_fee_per_gas,
            gas_limit: this.gas_limit,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        GasCostEstimationFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_gascostestimation_free(ptr, 0);
    }
    /**
     * The maximum fee the sender is willing to pay per unit of gas.
     * @returns {bigint}
     */
    get max_fee_per_gas() {
        const ret = wasm.__wbg_get_gascostestimation_max_fee_per_gas(this.__wbg_ptr);
        return (BigInt.asUintN(64, ret[0]) | (BigInt.asUintN(64, ret[1]) << BigInt(64)));
    }
    /**
     * The maximum fee the sender is willing to pay per unit of gas.
     * @param {bigint} arg0
     */
    set max_fee_per_gas(arg0) {
        wasm.__wbg_set_gascostestimation_max_fee_per_gas(this.__wbg_ptr, arg0, arg0 >> BigInt(64));
    }
    /**
     * The maximum tip the sender is willing to pay to miners (in EIP-1559).
     * @returns {bigint}
     */
    get max_priority_fee_per_gas() {
        const ret = wasm.__wbg_get_gascostestimation_max_priority_fee_per_gas(this.__wbg_ptr);
        return (BigInt.asUintN(64, ret[0]) | (BigInt.asUintN(64, ret[1]) << BigInt(64)));
    }
    /**
     * The maximum tip the sender is willing to pay to miners (in EIP-1559).
     * @param {bigint} arg0
     */
    set max_priority_fee_per_gas(arg0) {
        wasm.__wbg_set_gascostestimation_max_priority_fee_per_gas(this.__wbg_ptr, arg0, arg0 >> BigInt(64));
    }
    /**
     * The maximum amount of gas that the transaction can consume.
     * @returns {bigint}
     */
    get gas_limit() {
        const ret = wasm.__wbg_get_gascostestimation_gas_limit(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * The maximum amount of gas that the transaction can consume.
     * @param {bigint} arg0
     */
    set gas_limit(arg0) {
        wasm.__wbg_set_gascostestimation_gas_limit(this.__wbg_ptr, arg0);
    }
}

const KycAmlaQuestionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_kycamlaquestion_free(ptr >>> 0, 1));

export class KycAmlaQuestion {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(KycAmlaQuestion.prototype);
        obj.__wbg_ptr = ptr;
        KycAmlaQuestionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof KycAmlaQuestion)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    toJSON() {
        return {
            id: this.id,
            question: this.question,
            possible_answers: this.possible_answers,
            is_free_text: this.is_free_text,
            min_answers: this.min_answers,
            max_answers: this.max_answers,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        KycAmlaQuestionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_kycamlaquestion_free(ptr, 0);
    }
    /**
     * The unique ID of this question.
     * @returns {string}
     */
    get id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_kycamlaquestion_id(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * The unique ID of this question.
     * @param {string} arg0
     */
    set id(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_product_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The question the user has to answer.
     * @returns {string}
     */
    get question() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_kycamlaquestion_question(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * The question the user has to answer.
     * @param {string} arg0
     */
    set question(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_reason(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * A list of available answers that the user can choose from.
     * @returns {string[]}
     */
    get possible_answers() {
        const ret = wasm.__wbg_get_kycamlaquestion_possible_answers(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * A list of available answers that the user can choose from.
     * @param {string[]} arg0
     */
    set possible_answers(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_kycamlaquestion_possible_answers(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * Indicator if this question allows free text answers.
     * @returns {boolean}
     */
    get is_free_text() {
        const ret = wasm.__wbg_get_kycamlaquestion_is_free_text(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * Indicator if this question allows free text answers.
     * @param {boolean} arg0
     */
    set is_free_text(arg0) {
        wasm.__wbg_set_kycamlaquestion_is_free_text(this.__wbg_ptr, arg0);
    }
    /**
     * The minumum number of answers (including the free-text answer) that are required.
     * @returns {number}
     */
    get min_answers() {
        const ret = wasm.__wbg_get_kycamlaquestion_min_answers(this.__wbg_ptr);
        return ret;
    }
    /**
     * The minumum number of answers (including the free-text answer) that are required.
     * @param {number} arg0
     */
    set min_answers(arg0) {
        wasm.__wbg_set_kycamlaquestion_min_answers(this.__wbg_ptr, arg0);
    }
    /**
     * The maximum number of answers (including the free-text answer) that are allowed.
     * @returns {number}
     */
    get max_answers() {
        const ret = wasm.__wbg_get_kycamlaquestion_max_answers(this.__wbg_ptr);
        return ret;
    }
    /**
     * The maximum number of answers (including the free-text answer) that are allowed.
     * @param {number} arg0
     */
    set max_answers(arg0) {
        wasm.__wbg_set_kycamlaquestion_max_answers(this.__wbg_ptr, arg0);
    }
}

const KycOpenDocumentFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_kycopendocument_free(ptr >>> 0, 1));

export class KycOpenDocument {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(KycOpenDocument.prototype);
        obj.__wbg_ptr = ptr;
        KycOpenDocumentFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof KycOpenDocument)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    toJSON() {
        return {
            id: this.id,
            is_back_image_required: this.is_back_image_required,
            type: this.type,
            description: this.description,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        KycOpenDocumentFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_kycopendocument_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    get id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_kycopendocument_id(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set id(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_product_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {boolean}
     */
    get is_back_image_required() {
        const ret = wasm.__wbg_get_kycopendocument_is_back_image_required(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {boolean} arg0
     */
    set is_back_image_required(arg0) {
        wasm.__wbg_set_kycopendocument_is_back_image_required(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {string}
     */
    get type() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_kycopendocument_type(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set type(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_reason(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get description() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_kycopendocument_description(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set description(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_purchase_model(this.__wbg_ptr, ptr0, len0);
    }
}

const NetworkFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_network_free(ptr >>> 0, 1));

export class Network {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Network.prototype);
        obj.__wbg_ptr = ptr;
        NetworkFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    toJSON() {
        return {
            key: this.key,
            is_testnet: this.is_testnet,
            display_name: this.display_name,
            display_symbol: this.display_symbol,
            coin_type: this.coin_type,
            node_urls: this.node_urls,
            decimals: this.decimals,
            can_do_purchases: this.can_do_purchases,
            protocol_type: this.protocol_type,
            protocol_chain_id: this.protocol_chain_id,
            protocol_contract_address: this.protocol_contract_address,
            block_explorer_url: this.block_explorer_url,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NetworkFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_network_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    get key() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_network_key(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set key(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_network_key(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {boolean}
     */
    get is_testnet() {
        const ret = wasm.__wbg_get_network_is_testnet(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {boolean} arg0
     */
    set is_testnet(arg0) {
        wasm.__wbg_set_network_is_testnet(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {string}
     */
    get display_name() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_network_display_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set display_name(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_network_display_name(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get display_symbol() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_network_display_symbol(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set display_symbol(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_network_display_symbol(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {number}
     */
    get coin_type() {
        const ret = wasm.__wbg_get_network_coin_type(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} arg0
     */
    set coin_type(arg0) {
        wasm.__wbg_set_network_coin_type(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {string[]}
     */
    get node_urls() {
        const ret = wasm.__wbg_get_network_node_urls(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @param {string[]} arg0
     */
    set node_urls(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_network_node_urls(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {number}
     */
    get decimals() {
        const ret = wasm.__wbg_get_network_decimals(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} arg0
     */
    set decimals(arg0) {
        wasm.__wbg_set_network_decimals(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {boolean}
     */
    get can_do_purchases() {
        const ret = wasm.__wbg_get_network_can_do_purchases(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {boolean} arg0
     */
    set can_do_purchases(arg0) {
        wasm.__wbg_set_network_can_do_purchases(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {Protocol}
     */
    get protocol_type() {
        const ret = wasm.__wbg_get_network_protocol_type(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {Protocol} arg0
     */
    set protocol_type(arg0) {
        wasm.__wbg_set_network_protocol_type(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {bigint | undefined}
     */
    get protocol_chain_id() {
        const ret = wasm.__wbg_get_network_protocol_chain_id(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * @param {bigint | null} [arg0]
     */
    set protocol_chain_id(arg0) {
        wasm.__wbg_set_network_protocol_chain_id(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
     * @returns {string | undefined}
     */
    get protocol_contract_address() {
        const ret = wasm.__wbg_get_network_protocol_contract_address(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @param {string | null} [arg0]
     */
    set protocol_contract_address(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_network_protocol_contract_address(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get block_explorer_url() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_network_block_explorer_url(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set block_explorer_url(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_network_block_explorer_url(this.__wbg_ptr, ptr0, len0);
    }
}

const NewCaseIdResponseFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_newcaseidresponse_free(ptr >>> 0, 1));

export class NewCaseIdResponse {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NewCaseIdResponse.prototype);
        obj.__wbg_ptr = ptr;
        NewCaseIdResponseFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    toJSON() {
        return {
            case_id: this.case_id,
            case_url: this.case_url,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NewCaseIdResponseFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_newcaseidresponse_free(ptr, 0);
    }
    /**
     * New Postident case id
     * @returns {string}
     */
    get case_id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_newcaseidresponse_case_id(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * New Postident case id
     * @param {string} arg0
     */
    set case_id(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_product_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * Username
     * @returns {string}
     */
    get case_url() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_newcaseidresponse_case_url(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * Username
     * @param {string} arg0
     */
    set case_url(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_reason(this.__wbg_ptr, ptr0, len0);
    }
}

const NewViviswapUserFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_newviviswapuser_free(ptr >>> 0, 1));

export class NewViviswapUser {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(NewViviswapUser.prototype);
        obj.__wbg_ptr = ptr;
        NewViviswapUserFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    toJSON() {
        return {
            username: this.username,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        NewViviswapUserFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_newviviswapuser_free(ptr, 0);
    }
    /**
     * Username of new viviswap user
     * @returns {string}
     */
    get username() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_newviviswapuser_username(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * Username of new viviswap user
     * @param {string} arg0
     */
    set username(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_product_hash(this.__wbg_ptr, ptr0, len0);
    }
}

const OpenAmlaQuestionsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_openamlaquestions_free(ptr >>> 0, 1));

export class OpenAmlaQuestions {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(OpenAmlaQuestions.prototype);
        obj.__wbg_ptr = ptr;
        OpenAmlaQuestionsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    toJSON() {
        return {
            questions: this.questions,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        OpenAmlaQuestionsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_openamlaquestions_free(ptr, 0);
    }
    /**
     * @returns {KycAmlaQuestion[]}
     */
    get questions() {
        const ret = wasm.__wbg_get_openamlaquestions_questions(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @param {KycAmlaQuestion[]} arg0
     */
    set questions(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_openamlaquestions_questions(this.__wbg_ptr, ptr0, len0);
    }
}

const OpenDocumentsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_opendocuments_free(ptr >>> 0, 1));

export class OpenDocuments {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(OpenDocuments.prototype);
        obj.__wbg_ptr = ptr;
        OpenDocumentsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    toJSON() {
        return {
            documents: this.documents,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        OpenDocumentsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_opendocuments_free(ptr, 0);
    }
    /**
     * @returns {KycOpenDocument[]}
     */
    get documents() {
        const ret = wasm.__wbg_get_opendocuments_documents(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @param {KycOpenDocument[]} arg0
     */
    set documents(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_opendocuments_documents(this.__wbg_ptr, ptr0, len0);
    }
}

const OrderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_order_free(ptr >>> 0, 1));

export class Order {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Order.prototype);
        obj.__wbg_ptr = ptr;
        OrderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof Order)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    toJSON() {
        return {
            id: this.id,
            is_payed_out: this.is_payed_out,
            is_approved: this.is_approved,
            is_canceled: this.is_canceled,
            fees_amount_eur: this.fees_amount_eur,
            crypto_fees: this.crypto_fees,
            contract_id: this.contract_id,
            incoming_payment_method_id: this.incoming_payment_method_id,
            incoming_payment_method_currency: this.incoming_payment_method_currency,
            incoming_amount: this.incoming_amount,
            incoming_course: this.incoming_course,
            outgoing_payment_method_id: this.outgoing_payment_method_id,
            outgoing_payment_method_currency: this.outgoing_payment_method_currency,
            outgoing_amount: this.outgoing_amount,
            outgoing_course: this.outgoing_course,
            refund_amount: this.refund_amount,
            refund_course: this.refund_course,
            refund_payment_method_id: this.refund_payment_method_id,
            status: this.status,
            creation_date: this.creation_date,
            incoming_payment_detail: this.incoming_payment_detail,
            outgoing_payment_detail: this.outgoing_payment_detail,
            refund_payment_detail: this.refund_payment_detail,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        OrderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_order_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    get id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_order_id(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set id(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_order_id(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {boolean}
     */
    get is_payed_out() {
        const ret = wasm.__wbg_get_order_is_payed_out(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {boolean} arg0
     */
    set is_payed_out(arg0) {
        wasm.__wbg_set_order_is_payed_out(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {boolean}
     */
    get is_approved() {
        const ret = wasm.__wbg_get_order_is_approved(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {boolean} arg0
     */
    set is_approved(arg0) {
        wasm.__wbg_set_order_is_approved(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {boolean}
     */
    get is_canceled() {
        const ret = wasm.__wbg_get_order_is_canceled(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {boolean} arg0
     */
    set is_canceled(arg0) {
        wasm.__wbg_set_order_is_canceled(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {number}
     */
    get fees_amount_eur() {
        const ret = wasm.__wbg_get_order_fees_amount_eur(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} arg0
     */
    set fees_amount_eur(arg0) {
        wasm.__wbg_set_order_fees_amount_eur(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {number}
     */
    get crypto_fees() {
        const ret = wasm.__wbg_get_order_crypto_fees(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} arg0
     */
    set crypto_fees(arg0) {
        wasm.__wbg_set_order_crypto_fees(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {string}
     */
    get contract_id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_order_contract_id(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set contract_id(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_order_contract_id(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get incoming_payment_method_id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_order_incoming_payment_method_id(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set incoming_payment_method_id(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_order_incoming_payment_method_id(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get incoming_payment_method_currency() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_order_incoming_payment_method_currency(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set incoming_payment_method_currency(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_order_incoming_payment_method_currency(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {number}
     */
    get incoming_amount() {
        const ret = wasm.__wbg_get_order_incoming_amount(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} arg0
     */
    set incoming_amount(arg0) {
        wasm.__wbg_set_order_incoming_amount(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {number}
     */
    get incoming_course() {
        const ret = wasm.__wbg_get_order_incoming_course(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} arg0
     */
    set incoming_course(arg0) {
        wasm.__wbg_set_order_incoming_course(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {string}
     */
    get outgoing_payment_method_id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_order_outgoing_payment_method_id(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set outgoing_payment_method_id(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_order_outgoing_payment_method_id(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get outgoing_payment_method_currency() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_order_outgoing_payment_method_currency(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set outgoing_payment_method_currency(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_order_outgoing_payment_method_currency(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {number}
     */
    get outgoing_amount() {
        const ret = wasm.__wbg_get_order_outgoing_amount(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} arg0
     */
    set outgoing_amount(arg0) {
        wasm.__wbg_set_order_outgoing_amount(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {number}
     */
    get outgoing_course() {
        const ret = wasm.__wbg_get_order_outgoing_course(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} arg0
     */
    set outgoing_course(arg0) {
        wasm.__wbg_set_order_outgoing_course(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {number | undefined}
     */
    get refund_amount() {
        const ret = wasm.__wbg_get_order_refund_amount(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * @param {number | null} [arg0]
     */
    set refund_amount(arg0) {
        wasm.__wbg_set_order_refund_amount(this.__wbg_ptr, isLikeNone(arg0) ? 0x100000001 : Math.fround(arg0));
    }
    /**
     * @returns {number | undefined}
     */
    get refund_course() {
        const ret = wasm.__wbg_get_order_refund_course(this.__wbg_ptr);
        return ret === 0x100000001 ? undefined : ret;
    }
    /**
     * @param {number | null} [arg0]
     */
    set refund_course(arg0) {
        wasm.__wbg_set_order_refund_course(this.__wbg_ptr, isLikeNone(arg0) ? 0x100000001 : Math.fround(arg0));
    }
    /**
     * @returns {string | undefined}
     */
    get refund_payment_method_id() {
        const ret = wasm.__wbg_get_order_refund_payment_method_id(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @param {string | null} [arg0]
     */
    set refund_payment_method_id(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_order_refund_payment_method_id(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {number}
     */
    get status() {
        const ret = wasm.__wbg_get_order_status(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} arg0
     */
    set status(arg0) {
        wasm.__wbg_set_order_status(this.__wbg_ptr, arg0);
    }
    /**
     * @returns {string}
     */
    get creation_date() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_order_creation_date(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set creation_date(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_order_creation_date(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {PaymentDetail | undefined}
     */
    get incoming_payment_detail() {
        const ret = wasm.__wbg_get_order_incoming_payment_detail(this.__wbg_ptr);
        return ret === 0 ? undefined : PaymentDetail.__wrap(ret);
    }
    /**
     * @param {PaymentDetail | null} [arg0]
     */
    set incoming_payment_detail(arg0) {
        let ptr0 = 0;
        if (!isLikeNone(arg0)) {
            _assertClass(arg0, PaymentDetail);
            ptr0 = arg0.__destroy_into_raw();
        }
        wasm.__wbg_set_order_incoming_payment_detail(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {PaymentDetail | undefined}
     */
    get outgoing_payment_detail() {
        const ret = wasm.__wbg_get_order_outgoing_payment_detail(this.__wbg_ptr);
        return ret === 0 ? undefined : PaymentDetail.__wrap(ret);
    }
    /**
     * @param {PaymentDetail | null} [arg0]
     */
    set outgoing_payment_detail(arg0) {
        let ptr0 = 0;
        if (!isLikeNone(arg0)) {
            _assertClass(arg0, PaymentDetail);
            ptr0 = arg0.__destroy_into_raw();
        }
        wasm.__wbg_set_order_outgoing_payment_detail(this.__wbg_ptr, ptr0);
    }
    /**
     * @returns {PaymentDetail | undefined}
     */
    get refund_payment_detail() {
        const ret = wasm.__wbg_get_order_refund_payment_detail(this.__wbg_ptr);
        return ret === 0 ? undefined : PaymentDetail.__wrap(ret);
    }
    /**
     * @param {PaymentDetail | null} [arg0]
     */
    set refund_payment_detail(arg0) {
        let ptr0 = 0;
        if (!isLikeNone(arg0)) {
            _assertClass(arg0, PaymentDetail);
            ptr0 = arg0.__destroy_into_raw();
        }
        wasm.__wbg_set_order_refund_payment_detail(this.__wbg_ptr, ptr0);
    }
}

const OrderListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_orderlist_free(ptr >>> 0, 1));
/**
 * Orders list
 */
export class OrderList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(OrderList.prototype);
        obj.__wbg_ptr = ptr;
        OrderListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    toJSON() {
        return {
            orders: this.orders,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        OrderListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_orderlist_free(ptr, 0);
    }
    /**
     * @returns {Order[]}
     */
    get orders() {
        const ret = wasm.__wbg_get_orderlist_orders(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @param {Order[]} arg0
     */
    set orders(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_orderlist_orders(this.__wbg_ptr, ptr0, len0);
    }
}

const PaymentDetailFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_paymentdetail_free(ptr >>> 0, 1));

export class PaymentDetail {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PaymentDetail.prototype);
        obj.__wbg_ptr = ptr;
        PaymentDetailFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    toJSON() {
        return {
            id: this.id,
            address: this.address,
            is_verified: this.is_verified,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PaymentDetailFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_paymentdetail_free(ptr, 0);
    }
    /**
     * @returns {string}
     */
    get id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_paymentdetail_id(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set id(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_product_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {string}
     */
    get address() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_paymentdetail_address(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {string} arg0
     */
    set address(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_reason(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * @returns {boolean | undefined}
     */
    get is_verified() {
        const ret = wasm.__wbg_get_paymentdetail_is_verified(this.__wbg_ptr);
        return ret === 0xFFFFFF ? undefined : ret !== 0;
    }
    /**
     * @param {boolean | null} [arg0]
     */
    set is_verified(arg0) {
        wasm.__wbg_set_paymentdetail_is_verified(this.__wbg_ptr, isLikeNone(arg0) ? 0xFFFFFF : arg0 ? 1 : 0);
    }
}

const PurchaseDetailsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_purchasedetails_free(ptr >>> 0, 1));

export class PurchaseDetails {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PurchaseDetails.prototype);
        obj.__wbg_ptr = ptr;
        PurchaseDetailsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    toJSON() {
        return {
            main_address: this.main_address,
            amount: this.amount,
            status: this.status,
            invalid_reasons: this.invalid_reasons,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PurchaseDetailsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_purchasedetails_free(ptr, 0);
    }
    /**
     * The main address where the fees goes to.
     * @returns {string}
     */
    get main_address() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_purchasedetails_main_address(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * The main address where the fees goes to.
     * @param {string} arg0
     */
    set main_address(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_purchasedetails_main_address(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The amount to be paid.
     * @returns {number}
     */
    get amount() {
        const ret = wasm.__wbg_get_purchasedetails_amount(this.__wbg_ptr);
        return ret;
    }
    /**
     * The amount to be paid.
     * @param {number} arg0
     */
    set amount(arg0) {
        wasm.__wbg_set_purchasedetails_amount(this.__wbg_ptr, arg0);
    }
    /**
     * The status of transaction
     * @returns {TxStatus}
     */
    get status() {
        const ret = wasm.__wbg_get_purchasedetails_status(this.__wbg_ptr);
        return ret;
    }
    /**
     * The status of transaction
     * @param {TxStatus} arg0
     */
    set status(arg0) {
        wasm.__wbg_set_purchasedetails_status(this.__wbg_ptr, arg0);
    }
    /**
     * Transaction invalid reasons
     * @returns {string[]}
     */
    get invalid_reasons() {
        const ret = wasm.__wbg_get_purchasedetails_invalid_reasons(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * Transaction invalid reasons
     * @param {string[]} arg0
     */
    set invalid_reasons(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_kycamlaquestion_possible_answers(this.__wbg_ptr, ptr0, len0);
    }
}

const TxInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_txinfo_free(ptr >>> 0, 1));

export class TxInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TxInfo.prototype);
        obj.__wbg_ptr = ptr;
        TxInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof TxInfo)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    toJSON() {
        return {
            date: this.date,
            sender: this.sender,
            receiver: this.receiver,
            reference_id: this.reference_id,
            application_metadata: this.application_metadata,
            amount: this.amount,
            currency: this.currency,
            status: this.status,
            transaction_hash: this.transaction_hash,
            course: this.course,
            invalid_reasons: this.invalid_reasons,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TxInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_txinfo_free(ptr, 0);
    }
    /**
     * Tx creation date, if available
     * @returns {string | undefined}
     */
    get date() {
        const ret = wasm.__wbg_get_txinfo_date(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * Tx creation date, if available
     * @param {string | null} [arg0]
     */
    set date(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_txinfo_date(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * sender of the transaction
     * @returns {string}
     */
    get sender() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_txinfo_sender(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * sender of the transaction
     * @param {string} arg0
     */
    set sender(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_txinfo_sender(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * receiver of the transaction
     * @returns {string}
     */
    get receiver() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_txinfo_receiver(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * receiver of the transaction
     * @param {string} arg0
     */
    set receiver(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_txinfo_receiver(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * etopay reference id for the transaction
     * @returns {string}
     */
    get reference_id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_txinfo_reference_id(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * etopay reference id for the transaction
     * @param {string} arg0
     */
    set reference_id(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_txinfo_reference_id(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * Application specific metadata attached to the tx
     * @returns {ApplicationMetadata | undefined}
     */
    get application_metadata() {
        const ret = wasm.__wbg_get_txinfo_application_metadata(this.__wbg_ptr);
        return ret === 0 ? undefined : ApplicationMetadata.__wrap(ret);
    }
    /**
     * Application specific metadata attached to the tx
     * @param {ApplicationMetadata | null} [arg0]
     */
    set application_metadata(arg0) {
        let ptr0 = 0;
        if (!isLikeNone(arg0)) {
            _assertClass(arg0, ApplicationMetadata);
            ptr0 = arg0.__destroy_into_raw();
        }
        wasm.__wbg_set_txinfo_application_metadata(this.__wbg_ptr, ptr0);
    }
    /**
     * Amount of transfer
     * @returns {number}
     */
    get amount() {
        const ret = wasm.__wbg_get_txinfo_amount(this.__wbg_ptr);
        return ret;
    }
    /**
     * Amount of transfer
     * @param {number} arg0
     */
    set amount(arg0) {
        wasm.__wbg_set_txinfo_amount(this.__wbg_ptr, arg0);
    }
    /**
     * Currency of transfer
     * @returns {string}
     */
    get currency() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_txinfo_currency(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * Currency of transfer
     * @param {string} arg0
     */
    set currency(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_txinfo_currency(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * Status of the transfer
     * @returns {TxStatus}
     */
    get status() {
        const ret = wasm.__wbg_get_txinfo_status(this.__wbg_ptr);
        return ret;
    }
    /**
     * Status of the transfer
     * @param {TxStatus} arg0
     */
    set status(arg0) {
        wasm.__wbg_set_txinfo_status(this.__wbg_ptr, arg0);
    }
    /**
     * The transaction hash on the network
     * @returns {string | undefined}
     */
    get transaction_hash() {
        const ret = wasm.__wbg_get_txinfo_transaction_hash(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * The transaction hash on the network
     * @param {string | null} [arg0]
     */
    set transaction_hash(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_network_protocol_contract_address(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * Exchange rate
     * @returns {number}
     */
    get course() {
        const ret = wasm.__wbg_get_txinfo_course(this.__wbg_ptr);
        return ret;
    }
    /**
     * Exchange rate
     * @param {number} arg0
     */
    set course(arg0) {
        wasm.__wbg_set_txinfo_course(this.__wbg_ptr, arg0);
    }
    /**
     * Reasons in case of invalid tx
     * @returns {string[]}
     */
    get invalid_reasons() {
        const ret = wasm.__wbg_get_txinfo_invalid_reasons(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * Reasons in case of invalid tx
     * @param {string[]} arg0
     */
    set invalid_reasons(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_txinfo_invalid_reasons(this.__wbg_ptr, ptr0, len0);
    }
}

const TxListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_txlist_free(ptr >>> 0, 1));

export class TxList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TxList.prototype);
        obj.__wbg_ptr = ptr;
        TxListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    toJSON() {
        return {
            txs: this.txs,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TxListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_txlist_free(ptr, 0);
    }
    /**
     * @returns {TxInfo[]}
     */
    get txs() {
        const ret = wasm.__wbg_get_txlist_txs(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @param {TxInfo[]} arg0
     */
    set txs(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_txlist_txs(this.__wbg_ptr, ptr0, len0);
    }
}

const ViviswapAddressDetailFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_viviswapaddressdetail_free(ptr >>> 0, 1));

export class ViviswapAddressDetail {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ViviswapAddressDetail.prototype);
        obj.__wbg_ptr = ptr;
        ViviswapAddressDetailFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    toJSON() {
        return {
            id: this.id,
            address: this.address,
            is_verified: this.is_verified,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ViviswapAddressDetailFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_viviswapaddressdetail_free(ptr, 0);
    }
    /**
     * the unique id of the address detail
     * @returns {string}
     */
    get id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_viviswapaddressdetail_id(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * the unique id of the address detail
     * @param {string} arg0
     */
    set id(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_product_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * the address used in the detail
     * @returns {string}
     */
    get address() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_viviswapaddressdetail_address(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * the address used in the detail
     * @param {string} arg0
     */
    set address(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_reason(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * the status from viviswap, whether the address is verified
     * @returns {boolean}
     */
    get is_verified() {
        const ret = wasm.__wbg_get_casedetailsresponse_archived(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * the status from viviswap, whether the address is verified
     * @param {boolean} arg0
     */
    set is_verified(arg0) {
        wasm.__wbg_set_casedetailsresponse_archived(this.__wbg_ptr, arg0);
    }
}

const ViviswapDepositFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_viviswapdeposit_free(ptr >>> 0, 1));

export class ViviswapDeposit {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ViviswapDeposit.prototype);
        obj.__wbg_ptr = ptr;
        ViviswapDepositFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    toJSON() {
        return {
            contract_id: this.contract_id,
            deposit_address: this.deposit_address,
            details: this.details,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ViviswapDepositFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_viviswapdeposit_free(ptr, 0);
    }
    /**
     * The unique UUID of the contract
     * @returns {string}
     */
    get contract_id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_viviswapdeposit_contract_id(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * The unique UUID of the contract
     * @param {string} arg0
     */
    set contract_id(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_product_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The deposit address (crypto) where the swap will put the funds from fiat
     * @returns {string}
     */
    get deposit_address() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_viviswapdeposit_deposit_address(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * The deposit address (crypto) where the swap will put the funds from fiat
     * @param {string} arg0
     */
    set deposit_address(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_reason(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The details of the deposit (for the user)
     * @returns {ViviswapDepositDetails}
     */
    get details() {
        const ret = wasm.__wbg_get_viviswapdeposit_details(this.__wbg_ptr);
        return ViviswapDepositDetails.__wrap(ret);
    }
    /**
     * The details of the deposit (for the user)
     * @param {ViviswapDepositDetails} arg0
     */
    set details(arg0) {
        _assertClass(arg0, ViviswapDepositDetails);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_viviswapdeposit_details(this.__wbg_ptr, ptr0);
    }
}

const ViviswapDepositDetailsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_viviswapdepositdetails_free(ptr >>> 0, 1));

export class ViviswapDepositDetails {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ViviswapDepositDetails.prototype);
        obj.__wbg_ptr = ptr;
        ViviswapDepositDetailsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    toJSON() {
        return {
            reference: this.reference,
            beneficiary: this.beneficiary,
            name_of_bank: this.name_of_bank,
            address_of_bank: this.address_of_bank,
            iban: this.iban,
            bic: this.bic,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ViviswapDepositDetailsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_viviswapdepositdetails_free(ptr, 0);
    }
    /**
     * The reference to be entered by the user in his SEPA bank transfer
     * @returns {string}
     */
    get reference() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_viviswapdepositdetails_reference(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * The reference to be entered by the user in his SEPA bank transfer
     * @param {string} arg0
     */
    set reference(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_product_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The name of the beneficiary receiving the SEPA transfer
     * @returns {string}
     */
    get beneficiary() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_viviswapdepositdetails_beneficiary(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * The name of the beneficiary receiving the SEPA transfer
     * @param {string} arg0
     */
    set beneficiary(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_reason(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The name of the bank of the beneficiary
     * @returns {string}
     */
    get name_of_bank() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_viviswapdepositdetails_name_of_bank(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * The name of the bank of the beneficiary
     * @param {string} arg0
     */
    set name_of_bank(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_purchase_model(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The address of the bank of the beneficiary
     * @returns {string}
     */
    get address_of_bank() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_viviswapdepositdetails_address_of_bank(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * The address of the bank of the beneficiary
     * @param {string} arg0
     */
    set address_of_bank(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_app_data(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The IBAN of the beneficiary
     * @returns {string}
     */
    get iban() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_viviswapdepositdetails_iban(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * The IBAN of the beneficiary
     * @param {string} arg0
     */
    set iban(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_viviswapdepositdetails_iban(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The BIC/SWIFT code for the SEPA transfer
     * @returns {string}
     */
    get bic() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_viviswapdepositdetails_bic(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * The BIC/SWIFT code for the SEPA transfer
     * @param {string} arg0
     */
    set bic(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_viviswapdepositdetails_bic(this.__wbg_ptr, ptr0, len0);
    }
}

const ViviswapKycStatusFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_viviswapkycstatus_free(ptr >>> 0, 1));

export class ViviswapKycStatus {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ViviswapKycStatus.prototype);
        obj.__wbg_ptr = ptr;
        ViviswapKycStatusFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    toJSON() {
        return {
            full_name: this.full_name,
            submission_step: this.submission_step,
            verified_step: this.verified_step,
            verification_status: this.verification_status,
            monthly_limit_eur: this.monthly_limit_eur,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ViviswapKycStatusFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_viviswapkycstatus_free(ptr, 0);
    }
    /**
     * full name of the user
     * @returns {string}
     */
    get full_name() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_viviswapkycstatus_full_name(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * full name of the user
     * @param {string} arg0
     */
    set full_name(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_product_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * the current submission step in the KYC onboarding process for the user
     * @returns {ViviswapVerificationStep}
     */
    get submission_step() {
        const ret = wasm.__wbg_get_viviswapkycstatus_submission_step(this.__wbg_ptr);
        return ret;
    }
    /**
     * the current submission step in the KYC onboarding process for the user
     * @param {ViviswapVerificationStep} arg0
     */
    set submission_step(arg0) {
        wasm.__wbg_set_viviswapkycstatus_submission_step(this.__wbg_ptr, arg0);
    }
    /**
     * the current verified step in the KYC onboarding process for the user
     * @returns {ViviswapVerificationStep}
     */
    get verified_step() {
        const ret = wasm.__wbg_get_viviswapkycstatus_verified_step(this.__wbg_ptr);
        return ret;
    }
    /**
     * the current verified step in the KYC onboarding process for the user
     * @param {ViviswapVerificationStep} arg0
     */
    set verified_step(arg0) {
        wasm.__wbg_set_viviswapkycstatus_verified_step(this.__wbg_ptr, arg0);
    }
    /**
     * the user verification status
     * @returns {ViviswapVerificationStatus}
     */
    get verification_status() {
        const ret = wasm.__wbg_get_viviswapkycstatus_verification_status(this.__wbg_ptr);
        return ret;
    }
    /**
     * the user verification status
     * @param {ViviswapVerificationStatus} arg0
     */
    set verification_status(arg0) {
        wasm.__wbg_set_viviswapkycstatus_verification_status(this.__wbg_ptr, arg0);
    }
    /**
     * The monthly swap limit in euros
     * @returns {number}
     */
    get monthly_limit_eur() {
        const ret = wasm.__wbg_get_viviswapkycstatus_monthly_limit_eur(this.__wbg_ptr);
        return ret;
    }
    /**
     * The monthly swap limit in euros
     * @param {number} arg0
     */
    set monthly_limit_eur(arg0) {
        wasm.__wbg_set_viviswapkycstatus_monthly_limit_eur(this.__wbg_ptr, arg0);
    }
}

const ViviswapPartiallyKycDetailsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_viviswappartiallykycdetails_free(ptr >>> 0, 1));

export class ViviswapPartiallyKycDetails {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ViviswapPartiallyKycDetails.prototype);
        obj.__wbg_ptr = ptr;
        ViviswapPartiallyKycDetailsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    toJSON() {
        return {
            is_individual: this.is_individual,
            is_pep: this.is_pep,
            is_us_citizen: this.is_us_citizen,
            is_regulatory_disclosure: this.is_regulatory_disclosure,
            country_of_residence: this.country_of_residence,
            nationality: this.nationality,
            full_name: this.full_name,
            date_of_birth: this.date_of_birth,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ViviswapPartiallyKycDetailsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_viviswappartiallykycdetails_free(ptr, 0);
    }
    /**
     * Is the user an individual
     * @returns {boolean | undefined}
     */
    get is_individual() {
        const ret = wasm.__wbg_get_viviswappartiallykycdetails_is_individual(this.__wbg_ptr);
        return ret === 0xFFFFFF ? undefined : ret !== 0;
    }
    /**
     * Is the user an individual
     * @param {boolean | null} [arg0]
     */
    set is_individual(arg0) {
        wasm.__wbg_set_viviswappartiallykycdetails_is_individual(this.__wbg_ptr, isLikeNone(arg0) ? 0xFFFFFF : arg0 ? 1 : 0);
    }
    /**
     * Is the user a politically exposed person
     * @returns {boolean | undefined}
     */
    get is_pep() {
        const ret = wasm.__wbg_get_viviswappartiallykycdetails_is_pep(this.__wbg_ptr);
        return ret === 0xFFFFFF ? undefined : ret !== 0;
    }
    /**
     * Is the user a politically exposed person
     * @param {boolean | null} [arg0]
     */
    set is_pep(arg0) {
        wasm.__wbg_set_viviswappartiallykycdetails_is_pep(this.__wbg_ptr, isLikeNone(arg0) ? 0xFFFFFF : arg0 ? 1 : 0);
    }
    /**
     * Is the user a US citizen
     * @returns {boolean | undefined}
     */
    get is_us_citizen() {
        const ret = wasm.__wbg_get_viviswappartiallykycdetails_is_us_citizen(this.__wbg_ptr);
        return ret === 0xFFFFFF ? undefined : ret !== 0;
    }
    /**
     * Is the user a US citizen
     * @param {boolean | null} [arg0]
     */
    set is_us_citizen(arg0) {
        wasm.__wbg_set_viviswappartiallykycdetails_is_us_citizen(this.__wbg_ptr, isLikeNone(arg0) ? 0xFFFFFF : arg0 ? 1 : 0);
    }
    /**
     * Is the regulatory disclosure confirmed by user
     * @returns {boolean | undefined}
     */
    get is_regulatory_disclosure() {
        const ret = wasm.__wbg_get_viviswappartiallykycdetails_is_regulatory_disclosure(this.__wbg_ptr);
        return ret === 0xFFFFFF ? undefined : ret !== 0;
    }
    /**
     * Is the regulatory disclosure confirmed by user
     * @param {boolean | null} [arg0]
     */
    set is_regulatory_disclosure(arg0) {
        wasm.__wbg_set_viviswappartiallykycdetails_is_regulatory_disclosure(this.__wbg_ptr, isLikeNone(arg0) ? 0xFFFFFF : arg0 ? 1 : 0);
    }
    /**
     * The country of tax residence of the user
     * @returns {string | undefined}
     */
    get country_of_residence() {
        const ret = wasm.__wbg_get_viviswappartiallykycdetails_country_of_residence(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * The country of tax residence of the user
     * @param {string | null} [arg0]
     */
    set country_of_residence(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_viviswappartiallykycdetails_country_of_residence(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The user's nationality
     * @returns {string | undefined}
     */
    get nationality() {
        const ret = wasm.__wbg_get_viviswappartiallykycdetails_nationality(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * The user's nationality
     * @param {string | null} [arg0]
     */
    set nationality(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_viviswappartiallykycdetails_nationality(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The full name of the user as per his legal documents
     * @returns {string | undefined}
     */
    get full_name() {
        const ret = wasm.__wbg_get_viviswappartiallykycdetails_full_name(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * The full name of the user as per his legal documents
     * @param {string | null} [arg0]
     */
    set full_name(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_viviswappartiallykycdetails_full_name(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The date of birth of the user as per his legal documents
     * @returns {string | undefined}
     */
    get date_of_birth() {
        const ret = wasm.__wbg_get_viviswappartiallykycdetails_date_of_birth(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * The date of birth of the user as per his legal documents
     * @param {string | null} [arg0]
     */
    set date_of_birth(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_viviswappartiallykycdetails_date_of_birth(this.__wbg_ptr, ptr0, len0);
    }
}

const ViviswapWithdrawalFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_viviswapwithdrawal_free(ptr >>> 0, 1));
/**
 * The viviswap withdrawal contract information
 */
export class ViviswapWithdrawal {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ViviswapWithdrawal.prototype);
        obj.__wbg_ptr = ptr;
        ViviswapWithdrawalFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    toJSON() {
        return {
            contract_id: this.contract_id,
            deposit_address: this.deposit_address,
            details: this.details,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ViviswapWithdrawalFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_viviswapwithdrawal_free(ptr, 0);
    }
    /**
     * The unique UUID to track the withdrawal contract
     * @returns {string}
     */
    get contract_id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_viviswapwithdrawal_contract_id(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * The unique UUID to track the withdrawal contract
     * @param {string} arg0
     */
    set contract_id(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_product_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The deposit address, in this case the IBAN of the user, where fiat will be deposited.
     * @returns {string}
     */
    get deposit_address() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_viviswapwithdrawal_deposit_address(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * The deposit address, in this case the IBAN of the user, where fiat will be deposited.
     * @param {string} arg0
     */
    set deposit_address(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_reason(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The details of the withdrawal
     * @returns {ViviswapWithdrawalDetails}
     */
    get details() {
        const ret = wasm.__wbg_get_viviswapwithdrawal_details(this.__wbg_ptr);
        return ViviswapWithdrawalDetails.__wrap(ret);
    }
    /**
     * The details of the withdrawal
     * @param {ViviswapWithdrawalDetails} arg0
     */
    set details(arg0) {
        _assertClass(arg0, ViviswapWithdrawalDetails);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_viviswapwithdrawal_details(this.__wbg_ptr, ptr0);
    }
}

const ViviswapWithdrawalDetailsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_viviswapwithdrawaldetails_free(ptr >>> 0, 1));
/**
 * Viviswap withdrawal details for crypto to FIAT swap
 */
export class ViviswapWithdrawalDetails {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ViviswapWithdrawalDetails.prototype);
        obj.__wbg_ptr = ptr;
        ViviswapWithdrawalDetailsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    toJSON() {
        return {
            reference: this.reference,
            wallet_id: this.wallet_id,
            crypto_address: this.crypto_address,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ViviswapWithdrawalDetailsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_viviswapwithdrawaldetails_free(ptr, 0);
    }
    /**
     * The reference used by viviswap for the SEPA transfer
     * @returns {string}
     */
    get reference() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_viviswapwithdrawaldetails_reference(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * The reference used by viviswap for the SEPA transfer
     * @param {string} arg0
     */
    set reference(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_product_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The id of the unique wallet internal to viviswap
     * @returns {string}
     */
    get wallet_id() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_viviswapwithdrawaldetails_wallet_id(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * The id of the unique wallet internal to viviswap
     * @param {string} arg0
     */
    set wallet_id(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_reason(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The crypto address of viviswap where the crypto swap is to be sent
     * @returns {string}
     */
    get crypto_address() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_viviswapwithdrawaldetails_crypto_address(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * The crypto address of viviswap where the crypto swap is to be sent
     * @param {string} arg0
     */
    set crypto_address(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_applicationmetadata_purchase_model(this.__wbg_ptr, ptr0, len0);
    }
}

const WalletTxInfoFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_wallettxinfo_free(ptr >>> 0, 1));

export class WalletTxInfo {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WalletTxInfo.prototype);
        obj.__wbg_ptr = ptr;
        WalletTxInfoFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof WalletTxInfo)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    toJSON() {
        return {
            date: this.date,
            block_number: this.block_number,
            block_hash: this.block_hash,
            transaction_hash: this.transaction_hash,
            sender: this.sender,
            receiver: this.receiver,
            amount: this.amount,
            network_key: this.network_key,
            status: this.status,
            explorer_url: this.explorer_url,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WalletTxInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_wallettxinfo_free(ptr, 0);
    }
    /**
     * Tx creation date, if available
     * @returns {string}
     */
    get date() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_wallettxinfo_date(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * Tx creation date, if available
     * @param {string} arg0
     */
    set date(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_wallettxinfo_date(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * Contains block number / id
     * @returns {bigint | undefined}
     */
    get block_number() {
        const ret = wasm.__wbg_get_wallettxinfo_block_number(this.__wbg_ptr);
        return ret[0] === 0 ? undefined : BigInt.asUintN(64, ret[1]);
    }
    /**
     * Contains block number / id
     * @param {bigint | null} [arg0]
     */
    set block_number(arg0) {
        wasm.__wbg_set_network_protocol_chain_id(this.__wbg_ptr, !isLikeNone(arg0), isLikeNone(arg0) ? BigInt(0) : arg0);
    }
    /**
     * Contains block hash
     * @returns {string | undefined}
     */
    get block_hash() {
        const ret = wasm.__wbg_get_wallettxinfo_block_hash(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * Contains block hash
     * @param {string | null} [arg0]
     */
    set block_hash(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_wallettxinfo_block_hash(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * transaction id for particular transaction
     * @returns {string}
     */
    get transaction_hash() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_wallettxinfo_transaction_hash(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * transaction id for particular transaction
     * @param {string} arg0
     */
    set transaction_hash(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_order_incoming_payment_method_id(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The sender of the transaction
     * @returns {string}
     */
    get sender() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_wallettxinfo_sender(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * The sender of the transaction
     * @param {string} arg0
     */
    set sender(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_wallettxinfo_sender(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The receiver address
     * @returns {string}
     */
    get receiver() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_wallettxinfo_receiver(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * The receiver address
     * @param {string} arg0
     */
    set receiver(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_order_outgoing_payment_method_id(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * Amount of transfer
     * @returns {number}
     */
    get amount() {
        const ret = wasm.__wbg_get_wallettxinfo_amount(this.__wbg_ptr);
        return ret;
    }
    /**
     * Amount of transfer
     * @param {number} arg0
     */
    set amount(arg0) {
        wasm.__wbg_set_wallettxinfo_amount(this.__wbg_ptr, arg0);
    }
    /**
     * either SMR or IOTA
     * @returns {string}
     */
    get network_key() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.__wbg_get_wallettxinfo_network_key(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * either SMR or IOTA
     * @param {string} arg0
     */
    set network_key(arg0) {
        const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_wallettxinfo_network_key(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * Status of the transfer
     * @returns {WalletTxStatus}
     */
    get status() {
        const ret = wasm.__wbg_get_wallettxinfo_status(this.__wbg_ptr);
        return ret;
    }
    /**
     * Status of the transfer
     * @param {WalletTxStatus} arg0
     */
    set status(arg0) {
        wasm.__wbg_set_wallettxinfo_status(this.__wbg_ptr, arg0);
    }
    /**
     * Url of network explorer
     * @returns {string | undefined}
     */
    get explorer_url() {
        const ret = wasm.__wbg_get_wallettxinfo_explorer_url(this.__wbg_ptr);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * Url of network explorer
     * @param {string | null} [arg0]
     */
    set explorer_url(arg0) {
        var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_wallettxinfo_explorer_url(this.__wbg_ptr, ptr0, len0);
    }
}

const WalletTxInfoListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_wallettxinfolist_free(ptr >>> 0, 1));

export class WalletTxInfoList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WalletTxInfoList.prototype);
        obj.__wbg_ptr = ptr;
        WalletTxInfoListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    toJSON() {
        return {
            transactions: this.transactions,
        };
    }

    toString() {
        return JSON.stringify(this);
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WalletTxInfoListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_wallettxinfolist_free(ptr, 0);
    }
    /**
     * @returns {WalletTxInfo[]}
     */
    get transactions() {
        const ret = wasm.__wbg_get_wallettxinfolist_transactions(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @param {WalletTxInfo[]} arg0
     */
    set transactions(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_wallettxinfolist_transactions(this.__wbg_ptr, ptr0, len0);
    }
}

async function __wbg_load(module, imports) {
    if (typeof Response === 'function' && module instanceof Response) {
        if (typeof WebAssembly.instantiateStreaming === 'function') {
            try {
                return await WebAssembly.instantiateStreaming(module, imports);

            } catch (e) {
                if (module.headers.get('Content-Type') != 'application/wasm') {
                    console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);

                } else {
                    throw e;
                }
            }
        }

        const bytes = await module.arrayBuffer();
        return await WebAssembly.instantiate(bytes, imports);

    } else {
        const instance = await WebAssembly.instantiate(module, imports);

        if (instance instanceof WebAssembly.Instance) {
            return { instance, module };

        } else {
            return instance;
        }
    }
}

function __wbg_get_imports() {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbg_abort_410ec47a64ac6117 = function(arg0, arg1) {
        arg0.abort(arg1);
    };
    imports.wbg.__wbg_abort_775ef1d17fc65868 = function(arg0) {
        arg0.abort();
    };
    imports.wbg.__wbg_append_8c7dd8d641a5f01b = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {
        arg0.append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
    }, arguments) };
    imports.wbg.__wbg_arrayBuffer_d1b44c4390db422f = function() { return handleError(function (arg0) {
        const ret = arg0.arrayBuffer();
        return ret;
    }, arguments) };
    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {
        const ret = arg0.buffer;
        return ret;
    };
    imports.wbg.__wbg_call_672a4d21634d4a24 = function() { return handleError(function (arg0, arg1) {
        const ret = arg0.call(arg1);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_call_7cccdd69e0791ae2 = function() { return handleError(function (arg0, arg1, arg2) {
        const ret = arg0.call(arg1, arg2);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_casedetailsresponse_new = function(arg0) {
        const ret = CaseDetailsResponse.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_clearTimeout_121ece162c044c80 = function(arg0) {
        const ret = clearTimeout(arg0);
        return ret;
    };
    imports.wbg.__wbg_crypto_574e78ad8b13b65f = function(arg0) {
        const ret = arg0.crypto;
        return ret;
    };
    imports.wbg.__wbg_debug_3cb59063b29f58c1 = function(arg0) {
        console.debug(arg0);
    };
    imports.wbg.__wbg_done_769e5ede4b31c67b = function(arg0) {
        const ret = arg0.done;
        return ret;
    };
    imports.wbg.__wbg_error_524f506f44df1645 = function(arg0) {
        console.error(arg0);
    };
    imports.wbg.__wbg_error_7534b8e9a36f1ab4 = function(arg0, arg1) {
        let deferred0_0;
        let deferred0_1;
        try {
            deferred0_0 = arg0;
            deferred0_1 = arg1;
            console.error(getStringFromWasm0(arg0, arg1));
        } finally {
            wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);
        }
    };
    imports.wbg.__wbg_fetch_43e69ddf509149f8 = function(arg0) {
        const ret = fetch(arg0);
        return ret;
    };
    imports.wbg.__wbg_fetch_509096533071c657 = function(arg0, arg1) {
        const ret = arg0.fetch(arg1);
        return ret;
    };
    imports.wbg.__wbg_gascostestimation_new = function(arg0) {
        const ret = GasCostEstimation.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_getFullYear_17d3c9e4db748eb7 = function(arg0) {
        const ret = arg0.getFullYear();
        return ret;
    };
    imports.wbg.__wbg_getItem_17f98dee3b43fa7e = function() { return handleError(function (arg0, arg1, arg2, arg3) {
        const ret = arg1.getItem(getStringFromWasm0(arg2, arg3));
        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    }, arguments) };
    imports.wbg.__wbg_getRandomValues_38097e921c2494c3 = function() { return handleError(function (arg0, arg1) {
        globalThis.crypto.getRandomValues(getArrayU8FromWasm0(arg0, arg1));
    }, arguments) };
    imports.wbg.__wbg_getRandomValues_3c9c0d586e575a16 = function() { return handleError(function (arg0, arg1) {
        globalThis.crypto.getRandomValues(getArrayU8FromWasm0(arg0, arg1));
    }, arguments) };
    imports.wbg.__wbg_getRandomValues_b8f5dbd5f3995a9e = function() { return handleError(function (arg0, arg1) {
        arg0.getRandomValues(arg1);
    }, arguments) };
    imports.wbg.__wbg_getTime_46267b1c24877e30 = function(arg0) {
        const ret = arg0.getTime();
        return ret;
    };
    imports.wbg.__wbg_getTimezoneOffset_6b5752021c499c47 = function(arg0) {
        const ret = arg0.getTimezoneOffset();
        return ret;
    };
    imports.wbg.__wbg_get_67b2ba62fc30de12 = function() { return handleError(function (arg0, arg1) {
        const ret = Reflect.get(arg0, arg1);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_has_a5ea9117f258a0ec = function() { return handleError(function (arg0, arg1) {
        const ret = Reflect.has(arg0, arg1);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_headers_9cb51cfd2ac780a4 = function(arg0) {
        const ret = arg0.headers;
        return ret;
    };
    imports.wbg.__wbg_info_3daf2e093e091b66 = function(arg0) {
        console.info(arg0);
    };
    imports.wbg.__wbg_instanceof_Response_f2cc20d9f7dfd644 = function(arg0) {
        let result;
        try {
            result = arg0 instanceof Response;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    };
    imports.wbg.__wbg_iterator_9a24c88df860dc65 = function() {
        const ret = Symbol.iterator;
        return ret;
    };
    imports.wbg.__wbg_kycamlaquestion_new = function(arg0) {
        const ret = KycAmlaQuestion.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_kycamlaquestion_unwrap = function(arg0) {
        const ret = KycAmlaQuestion.__unwrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_kycopendocument_new = function(arg0) {
        const ret = KycOpenDocument.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_kycopendocument_unwrap = function(arg0) {
        const ret = KycOpenDocument.__unwrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_length_a446193dc22c12f8 = function(arg0) {
        const ret = arg0.length;
        return ret;
    };
    imports.wbg.__wbg_log_c222819a41e063d3 = function(arg0) {
        console.log(arg0);
    };
    imports.wbg.__wbg_msCrypto_a61aeb35a24c1329 = function(arg0) {
        const ret = arg0.msCrypto;
        return ret;
    };
    imports.wbg.__wbg_network_new = function(arg0) {
        const ret = Network.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_new0_f788a2397c7ca929 = function() {
        const ret = new Date();
        return ret;
    };
    imports.wbg.__wbg_new_018dcc2d6c8c2f6a = function() { return handleError(function () {
        const ret = new Headers();
        return ret;
    }, arguments) };
    imports.wbg.__wbg_new_23a2665fac83c611 = function(arg0, arg1) {
        try {
            var state0 = {a: arg0, b: arg1};
            var cb0 = (arg0, arg1) => {
                const a = state0.a;
                state0.a = 0;
                try {
                    return __wbg_adapter_530(a, state0.b, arg0, arg1);
                } finally {
                    state0.a = a;
                }
            };
            const ret = new Promise(cb0);
            return ret;
        } finally {
            state0.a = state0.b = 0;
        }
    };
    imports.wbg.__wbg_new_31a97dac4f10fab7 = function(arg0) {
        const ret = new Date(arg0);
        return ret;
    };
    imports.wbg.__wbg_new_405e22f390576ce2 = function() {
        const ret = new Object();
        return ret;
    };
    imports.wbg.__wbg_new_8a6f238a6ece86ea = function() {
        const ret = new Error();
        return ret;
    };
    imports.wbg.__wbg_new_a12002a7f91c75be = function(arg0) {
        const ret = new Uint8Array(arg0);
        return ret;
    };
    imports.wbg.__wbg_new_e25e5aab09ff45db = function() { return handleError(function () {
        const ret = new AbortController();
        return ret;
    }, arguments) };
    imports.wbg.__wbg_newcaseidresponse_new = function(arg0) {
        const ret = NewCaseIdResponse.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_newnoargs_105ed471475aaf50 = function(arg0, arg1) {
        const ret = new Function(getStringFromWasm0(arg0, arg1));
        return ret;
    };
    imports.wbg.__wbg_newviviswapuser_new = function(arg0) {
        const ret = NewViviswapUser.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function(arg0, arg1, arg2) {
        const ret = new Uint8Array(arg0, arg1 >>> 0, arg2 >>> 0);
        return ret;
    };
    imports.wbg.__wbg_newwithlength_a381634e90c276d4 = function(arg0) {
        const ret = new Uint8Array(arg0 >>> 0);
        return ret;
    };
    imports.wbg.__wbg_newwithstrandinit_06c535e0a867c635 = function() { return handleError(function (arg0, arg1, arg2) {
        const ret = new Request(getStringFromWasm0(arg0, arg1), arg2);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_next_25feadfc0913fea9 = function(arg0) {
        const ret = arg0.next;
        return ret;
    };
    imports.wbg.__wbg_next_6574e1a8a62d1055 = function() { return handleError(function (arg0) {
        const ret = arg0.next();
        return ret;
    }, arguments) };
    imports.wbg.__wbg_node_905d3e251edff8a2 = function(arg0) {
        const ret = arg0.node;
        return ret;
    };
    imports.wbg.__wbg_now_2c95c9de01293173 = function(arg0) {
        const ret = arg0.now();
        return ret;
    };
    imports.wbg.__wbg_now_d18023d54d4e5500 = function(arg0) {
        const ret = arg0.now();
        return ret;
    };
    imports.wbg.__wbg_now_fb0466b5460cff09 = function(arg0) {
        const ret = arg0.now();
        return ret;
    };
    imports.wbg.__wbg_openamlaquestions_new = function(arg0) {
        const ret = OpenAmlaQuestions.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_opendocuments_new = function(arg0) {
        const ret = OpenDocuments.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_order_new = function(arg0) {
        const ret = Order.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_order_unwrap = function(arg0) {
        const ret = Order.__unwrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_orderlist_new = function(arg0) {
        const ret = OrderList.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_performance_71b063e177862740 = function(arg0) {
        const ret = arg0.performance;
        return ret;
    };
    imports.wbg.__wbg_performance_7a3ffd0b17f663ad = function(arg0) {
        const ret = arg0.performance;
        return ret;
    };
    imports.wbg.__wbg_process_dc0fbacc7c1c06f7 = function(arg0) {
        const ret = arg0.process;
        return ret;
    };
    imports.wbg.__wbg_purchasedetails_new = function(arg0) {
        const ret = PurchaseDetails.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_queueMicrotask_97d92b4fcc8a61c5 = function(arg0) {
        queueMicrotask(arg0);
    };
    imports.wbg.__wbg_queueMicrotask_d3219def82552485 = function(arg0) {
        const ret = arg0.queueMicrotask;
        return ret;
    };
    imports.wbg.__wbg_randomFillSync_ac0988aba3254290 = function() { return handleError(function (arg0, arg1) {
        arg0.randomFillSync(arg1);
    }, arguments) };
    imports.wbg.__wbg_removeItem_9d2669ee3bba6f7d = function() { return handleError(function (arg0, arg1, arg2) {
        arg0.removeItem(getStringFromWasm0(arg1, arg2));
    }, arguments) };
    imports.wbg.__wbg_require_60cc747a6bc5215a = function() { return handleError(function () {
        const ret = module.require;
        return ret;
    }, arguments) };
    imports.wbg.__wbg_resolve_4851785c9c5f573d = function(arg0) {
        const ret = Promise.resolve(arg0);
        return ret;
    };
    imports.wbg.__wbg_setItem_212ecc915942ab0a = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {
        arg0.setItem(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
    }, arguments) };
    imports.wbg.__wbg_setTimeout_25eabdb2fc442ea2 = function() { return handleError(function (arg0, arg1, arg2) {
        const ret = arg0.setTimeout(arg1, arg2);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_setTimeout_e64b2910d9d7169a = function(arg0, arg1) {
        const ret = setTimeout(arg0, arg1);
        return ret;
    };
    imports.wbg.__wbg_set_65595bdd868b3009 = function(arg0, arg1, arg2) {
        arg0.set(arg1, arg2 >>> 0);
    };
    imports.wbg.__wbg_setbody_5923b78a95eedf29 = function(arg0, arg1) {
        arg0.body = arg1;
    };
    imports.wbg.__wbg_setcredentials_c3a22f1cd105a2c6 = function(arg0, arg1) {
        arg0.credentials = __wbindgen_enum_RequestCredentials[arg1];
    };
    imports.wbg.__wbg_setheaders_834c0bdb6a8949ad = function(arg0, arg1) {
        arg0.headers = arg1;
    };
    imports.wbg.__wbg_setmethod_3c5280fe5d890842 = function(arg0, arg1, arg2) {
        arg0.method = getStringFromWasm0(arg1, arg2);
    };
    imports.wbg.__wbg_setmode_5dc300b865044b65 = function(arg0, arg1) {
        arg0.mode = __wbindgen_enum_RequestMode[arg1];
    };
    imports.wbg.__wbg_setsignal_75b21ef3a81de905 = function(arg0, arg1) {
        arg0.signal = arg1;
    };
    imports.wbg.__wbg_signal_aaf9ad74119f20a4 = function(arg0) {
        const ret = arg0.signal;
        return ret;
    };
    imports.wbg.__wbg_stack_0ed75d68575b0f3c = function(arg0, arg1) {
        const ret = arg1.stack;
        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {
        const ret = typeof global === 'undefined' ? null : global;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {
        const ret = typeof globalThis === 'undefined' ? null : globalThis;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {
        const ret = typeof self === 'undefined' ? null : self;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {
        const ret = typeof window === 'undefined' ? null : window;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_static_accessor_performance_da77b3a901a72934 = function() {
        const ret = performance;
        return ret;
    };
    imports.wbg.__wbg_status_f6360336ca686bf0 = function(arg0) {
        const ret = arg0.status;
        return ret;
    };
    imports.wbg.__wbg_stringify_f7ed6987935b4a24 = function() { return handleError(function (arg0) {
        const ret = JSON.stringify(arg0);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(arg0, arg1, arg2) {
        const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);
        return ret;
    };
    imports.wbg.__wbg_text_7805bea50de2af49 = function() { return handleError(function (arg0) {
        const ret = arg0.text();
        return ret;
    }, arguments) };
    imports.wbg.__wbg_then_44b73946d2fb3e7d = function(arg0, arg1) {
        const ret = arg0.then(arg1);
        return ret;
    };
    imports.wbg.__wbg_then_48b406749878a531 = function(arg0, arg1, arg2) {
        const ret = arg0.then(arg1, arg2);
        return ret;
    };
    imports.wbg.__wbg_txinfo_new = function(arg0) {
        const ret = TxInfo.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_txinfo_unwrap = function(arg0) {
        const ret = TxInfo.__unwrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_txlist_new = function(arg0) {
        const ret = TxList.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_url_ae10c34ca209681d = function(arg0, arg1) {
        const ret = arg1.url;
        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbg_value_cd1ffa7b1ab794f1 = function(arg0) {
        const ret = arg0.value;
        return ret;
    };
    imports.wbg.__wbg_versions_c01dfd4722a88165 = function(arg0) {
        const ret = arg0.versions;
        return ret;
    };
    imports.wbg.__wbg_viviswapaddressdetail_new = function(arg0) {
        const ret = ViviswapAddressDetail.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_viviswapdeposit_new = function(arg0) {
        const ret = ViviswapDeposit.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_viviswapkycstatus_new = function(arg0) {
        const ret = ViviswapKycStatus.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_viviswappartiallykycdetails_new = function(arg0) {
        const ret = ViviswapPartiallyKycDetails.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_viviswapwithdrawal_new = function(arg0) {
        const ret = ViviswapWithdrawal.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_wallettxinfo_new = function(arg0) {
        const ret = WalletTxInfo.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_wallettxinfo_unwrap = function(arg0) {
        const ret = WalletTxInfo.__unwrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_wallettxinfolist_new = function(arg0) {
        const ret = WalletTxInfoList.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_warn_4ca3906c248c47c4 = function(arg0) {
        console.warn(arg0);
    };
    imports.wbg.__wbindgen_array_new = function() {
        const ret = [];
        return ret;
    };
    imports.wbg.__wbindgen_array_push = function(arg0, arg1) {
        arg0.push(arg1);
    };
    imports.wbg.__wbindgen_cb_drop = function(arg0) {
        const obj = arg0.original;
        if (obj.cnt-- == 1) {
            obj.a = 0;
            return true;
        }
        const ret = false;
        return ret;
    };
    imports.wbg.__wbindgen_closure_wrapper10319 = function(arg0, arg1, arg2) {
        const ret = makeMutClosure(arg0, arg1, 3191, __wbg_adapter_36);
        return ret;
    };
    imports.wbg.__wbindgen_closure_wrapper11550 = function(arg0, arg1, arg2) {
        const ret = makeMutClosure(arg0, arg1, 3453, __wbg_adapter_39);
        return ret;
    };
    imports.wbg.__wbindgen_closure_wrapper11666 = function(arg0, arg1, arg2) {
        const ret = makeMutClosure(arg0, arg1, 3504, __wbg_adapter_42);
        return ret;
    };
    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
        const ret = debugString(arg1);
        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbindgen_init_externref_table = function() {
        const table = wasm.__wbindgen_export_2;
        const offset = table.grow(4);
        table.set(0, undefined);
        table.set(offset + 0, undefined);
        table.set(offset + 1, null);
        table.set(offset + 2, true);
        table.set(offset + 3, false);
        ;
    };
    imports.wbg.__wbindgen_is_function = function(arg0) {
        const ret = typeof(arg0) === 'function';
        return ret;
    };
    imports.wbg.__wbindgen_is_object = function(arg0) {
        const val = arg0;
        const ret = typeof(val) === 'object' && val !== null;
        return ret;
    };
    imports.wbg.__wbindgen_is_string = function(arg0) {
        const ret = typeof(arg0) === 'string';
        return ret;
    };
    imports.wbg.__wbindgen_is_undefined = function(arg0) {
        const ret = arg0 === undefined;
        return ret;
    };
    imports.wbg.__wbindgen_memory = function() {
        const ret = wasm.memory;
        return ret;
    };
    imports.wbg.__wbindgen_number_new = function(arg0) {
        const ret = arg0;
        return ret;
    };
    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
        const obj = arg1;
        const ret = typeof(obj) === 'string' ? obj : undefined;
        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
        const ret = getStringFromWasm0(arg0, arg1);
        return ret;
    };
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
        throw new Error(getStringFromWasm0(arg0, arg1));
    };
    imports.wbg.__wbindgen_uint8_array_new = function(arg0, arg1) {
        var v0 = getArrayU8FromWasm0(arg0, arg1).slice();
        wasm.__wbindgen_free(arg0, arg1 * 1, 1);
        const ret = v0;
        return ret;
    };

    return imports;
}

function __wbg_init_memory(imports, memory) {

}

function __wbg_finalize_init(instance, module) {
    wasm = instance.exports;
    __wbg_init.__wbindgen_wasm_module = module;
    cachedDataViewMemory0 = null;
    cachedUint8ArrayMemory0 = null;


    wasm.__wbindgen_start();
    return wasm;
}

function initSync(module) {
    if (wasm !== undefined) return wasm;


    if (typeof module !== 'undefined') {
        if (Object.getPrototypeOf(module) === Object.prototype) {
            ({module} = module)
        } else {
            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')
        }
    }

    const imports = __wbg_get_imports();

    __wbg_init_memory(imports);

    if (!(module instanceof WebAssembly.Module)) {
        module = new WebAssembly.Module(module);
    }

    const instance = new WebAssembly.Instance(module, imports);

    return __wbg_finalize_init(instance, module);
}

async function __wbg_init(module_or_path) {
    if (wasm !== undefined) return wasm;


    if (typeof module_or_path !== 'undefined') {
        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
            ({module_or_path} = module_or_path)
        } else {
            console.warn('using deprecated parameters for the initialization function; pass a single object instead')
        }
    }

    if (typeof module_or_path === 'undefined') {
        module_or_path = new URL('etopay_sdk_wasm_bg.wasm', import.meta.url);
    }
    const imports = __wbg_get_imports();

    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {
        module_or_path = fetch(module_or_path);
    }

    __wbg_init_memory(imports);

    const { instance, module } = await __wbg_load(await module_or_path, imports);

    return __wbg_finalize_init(instance, module);
}

export { initSync };
export default __wbg_init;
